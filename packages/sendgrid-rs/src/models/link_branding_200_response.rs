/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct LinkBranding200Response {
    /// The ID of the branded link.
    #[serde(rename = "id", deserialize_with = "Option::deserialize")]
    pub id: Option<serde_json::Value>,
    /// The root domain of the branded link.
    #[serde(rename = "domain", deserialize_with = "Option::deserialize")]
    pub domain: Option<serde_json::Value>,
    /// The subdomain used to generate the DNS records for this link branding. This subdomain must be different from the subdomain used for your authenticated domain.
    #[serde(rename = "subdomain", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub subdomain: Option<Option<serde_json::Value>>,
    /// The username of the account that this link branding is associated with.
    #[serde(rename = "username", deserialize_with = "Option::deserialize")]
    pub username: Option<serde_json::Value>,
    /// The ID of the user that this link branding is associated with.
    #[serde(rename = "user_id", deserialize_with = "Option::deserialize")]
    pub user_id: Option<serde_json::Value>,
    /// Indicates if this is the default link branding.
    #[serde(rename = "default", deserialize_with = "Option::deserialize")]
    pub default: Option<Default>,
    /// Indicates if this link branding is valid.
    #[serde(rename = "valid", deserialize_with = "Option::deserialize")]
    pub valid: Option<Valid>,
    /// Indicates if this link branding was created using the legacy whitelabel tool. If it is a legacy whitelabel, it will still function, but you'll need to create new link branding if you need to update it.
    #[serde(rename = "legacy", deserialize_with = "Option::deserialize")]
    pub legacy: Option<Legacy>,
    #[serde(rename = "dns")]
    pub dns: Box<crate::models::LinkBranding200ResponseDns>,
}

impl LinkBranding200Response {
    pub fn new(id: Option<serde_json::Value>, domain: Option<serde_json::Value>, username: Option<serde_json::Value>, user_id: Option<serde_json::Value>, default: Option<Default>, valid: Option<Valid>, legacy: Option<Legacy>, dns: crate::models::LinkBranding200ResponseDns) -> LinkBranding200Response {
        LinkBranding200Response {
            id,
            domain,
            subdomain: None,
            username,
            user_id,
            default,
            valid,
            legacy,
            dns: Box::new(dns),
        }
    }
}

/// Indicates if this is the default link branding.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Default {
    #[serde(rename = "true")]
    True,
    #[serde(rename = "false")]
    False,
}

impl std::default::Default for Default {
    fn default() -> Default {
        Self::True
    }
}
/// Indicates if this link branding is valid.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Valid {
    #[serde(rename = "true")]
    True,
    #[serde(rename = "false")]
    False,
}

impl std::default::Default for Valid {
    fn default() -> Valid {
        Self::True
    }
}
/// Indicates if this link branding was created using the legacy whitelabel tool. If it is a legacy whitelabel, it will still function, but you'll need to create new link branding if you need to update it.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Legacy {
    #[serde(rename = "true")]
    True,
    #[serde(rename = "false")]
    False,
}

impl std::default::Default for Legacy {
    fn default() -> Legacy {
        Self::True
    }
}

