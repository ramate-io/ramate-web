/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`g_etv3_messages_download_download_uuid`]
#[derive(Clone, Debug, Default)]
pub struct GEtv3MessagesDownloadDownloadUuidParams {
    pub authorization: serde_json::Value,
    /// UUID used to locate the download csv request entry in the DB.  This is the UUID provided in the email sent to the user when their csv file is ready to download
    pub download_uuid: serde_json::Value
}

/// struct for passing parameters to the method [`p_ostv3_messages_download`]
#[derive(Clone, Debug, Default)]
pub struct POstv3MessagesDownloadParams {
    pub authorization: serde_json::Value,
    /// Uses a SQL like syntax to indicate which messages to include in the CSV
    pub query: Option<serde_json::Value>
}


/// struct for typed errors of method [`g_etv3_messages_download_download_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtv3MessagesDownloadDownloadUuidError {
    Status404(crate::models::PostMcContactsSearch500Response),
    Status500(crate::models::PostMcContactsSearch500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ostv3_messages_download`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstv3MessagesDownloadError {
    Status400(crate::models::PostMcContactsSearch500Response),
    Status429(crate::models::PostMcContactsSearch500Response),
    Status500(crate::models::PostMcContactsSearch500Response),
    UnknownValue(serde_json::Value),
}


/// **This endpoint will return a presigned URL that can be used to download the CSV that was requested from the \"Request a CSV\" endpoint.**
pub async fn g_etv3_messages_download_download_uuid(configuration: &configuration::Configuration, params: GEtv3MessagesDownloadDownloadUuidParams) -> Result<crate::models::GetV3MessagesDownloadDownloadUuid200Response, Error<GEtv3MessagesDownloadDownloadUuidError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let authorization = params.authorization;
    let download_uuid = params.download_uuid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/messages/download/{download_uuid}", local_var_configuration.base_path, download_uuid=download_uuid);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtv3MessagesDownloadDownloadUuidError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This is BETA functionality. You may not have access, and we reserve the right to change functionality without notice.  This request will kick off a backend process to generate a CSV file. Once generated, the worker will then send an email for the user download the file. The link will expire in 3 days.  The CSV fill contain the last 1 million messages. This endpoint will be rate limited to 1 request every 12 hours (rate limit may change).  This endpoint is similar to the GET Single Message endpoint - the only difference is that /download is added to indicate that this is a CSV download requests but the same query is used to determine what the CSV should contain.
pub async fn p_ostv3_messages_download(configuration: &configuration::Configuration, params: POstv3MessagesDownloadParams) -> Result<crate::models::PostV3MessagesDownload202Response, Error<POstv3MessagesDownloadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let authorization = params.authorization;
    let query = params.query;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/messages/download", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstv3MessagesDownloadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

