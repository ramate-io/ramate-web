/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_asm_suppressions_global_email`]
#[derive(Clone, Debug, Default)]
pub struct DEleteAsmSuppressionsGlobalEmailParams {
    /// The email address of the global suppression you want to retrieve. Or, if you want to check if an email address is on the global suppressions list, enter that email address here.
    pub email: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_asm_suppressions_global_email`]
#[derive(Clone, Debug, Default)]
pub struct GEtAsmSuppressionsGlobalEmailParams {
    /// The email address of the global suppression you want to retrieve. Or, if you want to check if an email address is on the global suppressions list, enter that email address here.
    pub email: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_suppression_unsubscribes`]
#[derive(Clone, Debug, Default)]
pub struct GEtSuppressionUnsubscribesParams {
    /// Refers start of the time range in unix timestamp when an unsubscribe email was created (inclusive).
    pub start_time: Option<serde_json::Value>,
    /// Refers end of the time range in unix timestamp when an unsubscribe email was created (inclusive).
    pub end_time: Option<serde_json::Value>,
    /// The number of results to display on each page.
    pub limit: Option<serde_json::Value>,
    /// The point in the list of results to begin displaying global suppressions.
    pub offset: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_ost_asm_suppressions_global`]
#[derive(Clone, Debug, Default)]
pub struct POstAsmSuppressionsGlobalParams {
    pub on_behalf_of: Option<serde_json::Value>,
    pub suppressions_request: Option<crate::models::SuppressionsRequest>
}


/// struct for typed errors of method [`d_elete_asm_suppressions_global_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteAsmSuppressionsGlobalEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_asm_suppressions_global_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtAsmSuppressionsGlobalEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_suppression_unsubscribes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtSuppressionUnsubscribesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_asm_suppressions_global`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstAsmSuppressionsGlobalError {
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to remove an email address from the global suppressions group.**  Deleting a suppression group will remove the suppression, meaning email will once again be sent to the previously suppressed addresses. This should be avoided unless a recipient indicates they wish to receive email from you again. You can use our [bypass filters](https://sendgrid.com/docs/ui/sending-email/index-suppressions/#bypass-suppressions) to deliver messages to otherwise suppressed addresses when exceptions are required.
pub async fn d_elete_asm_suppressions_global_email(configuration: &configuration::Configuration, params: DEleteAsmSuppressionsGlobalEmailParams) -> Result<serde_json::Value, Error<DEleteAsmSuppressionsGlobalEmailError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let email = params.email;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/asm/suppressions/global/{email}", local_var_configuration.base_path, email=email);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteAsmSuppressionsGlobalEmailError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a global suppression. You can also use this endpoint to confirm if an email address is already globally suppresed.**  If the email address you include in the URL path parameter `{email}` is already globally suppressed, the response will include that email address. If the address you enter for `{email}` is not globally suppressed, an empty JSON object `{}` will be returned.
pub async fn g_et_asm_suppressions_global_email(configuration: &configuration::Configuration, params: GEtAsmSuppressionsGlobalEmailParams) -> Result<crate::models::RetrieveAGlobalSuppressionResponse, Error<GEtAsmSuppressionsGlobalEmailError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let email = params.email;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/asm/suppressions/global/{email}", local_var_configuration.base_path, email=email);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtAsmSuppressionsGlobalEmailError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a list of all email address that are globally suppressed.**
pub async fn g_et_suppression_unsubscribes(configuration: &configuration::Configuration, params: GEtSuppressionUnsubscribesParams) -> Result<serde_json::Value, Error<GEtSuppressionUnsubscribesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let start_time = params.start_time;
    let end_time = params.end_time;
    let limit = params.limit;
    let offset = params.offset;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/suppression/unsubscribes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start_time {
        local_var_req_builder = local_var_req_builder.query(&[("start_time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_time {
        local_var_req_builder = local_var_req_builder.query(&[("end_time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtSuppressionUnsubscribesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to add one or more email addresses to the global suppressions group.**
pub async fn p_ost_asm_suppressions_global(configuration: &configuration::Configuration, params: POstAsmSuppressionsGlobalParams) -> Result<crate::models::PostAsmSuppressionsGlobal201Response, Error<POstAsmSuppressionsGlobalError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;
    let suppressions_request = params.suppressions_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/asm/suppressions/global", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&suppressions_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstAsmSuppressionsGlobalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

