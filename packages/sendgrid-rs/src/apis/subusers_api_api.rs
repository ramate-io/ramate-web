/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_subusers_subuser_name`]
#[derive(Clone, Debug, Default)]
pub struct DEleteSubusersSubuserNameParams {
    pub subuser_name: serde_json::Value
}

/// struct for passing parameters to the method [`g_et_subusers`]
#[derive(Clone, Debug, Default)]
pub struct GEtSubusersParams {
    /// The username of this subuser.
    pub username: Option<serde_json::Value>,
    /// The number of results you would like to get in each request.
    pub limit: Option<serde_json::Value>,
    /// The number of subusers to skip.
    pub offset: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_subusers_reputations`]
#[derive(Clone, Debug, Default)]
pub struct GEtSubusersReputationsParams {
    pub usernames: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_atch_subusers_subuser_name`]
#[derive(Clone, Debug, Default)]
pub struct PAtchSubusersSubuserNameParams {
    pub subuser_name: serde_json::Value,
    pub patch_subusers_subuser_name_request: Option<crate::models::PatchSubusersSubuserNameRequest>
}

/// struct for passing parameters to the method [`p_ost_subusers`]
#[derive(Clone, Debug, Default)]
pub struct POstSubusersParams {
    pub post_subusers_request: Option<crate::models::PostSubusersRequest>
}

/// struct for passing parameters to the method [`p_ut_subusers_subuser_name_ips`]
#[derive(Clone, Debug, Default)]
pub struct PUtSubusersSubuserNameIpsParams {
    pub subuser_name: serde_json::Value,
    pub body: Option<serde_json::Value>
}


/// struct for typed errors of method [`d_elete_subusers_subuser_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteSubusersSubuserNameError {
    Status401(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_subusers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtSubusersError {
    Status401(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_subusers_reputations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtSubusersReputationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_subusers_subuser_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchSubusersSubuserNameError {
    Status400(crate::models::GlobalErrorResponseSchema),
    Status401(crate::models::GlobalErrorResponseSchema),
    Status500(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_subusers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstSubusersError {
    Status400(crate::models::GlobalErrorResponseSchema),
    Status401(crate::models::GlobalErrorResponseSchema),
    Status403(crate::models::GlobalErrorResponseSchema),
    Status500(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ut_subusers_subuser_name_ips`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PUtSubusersSubuserNameIpsError {
    Status401(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to delete a subuser.**  This is a permanent action. Once deleted, a subuser cannot be retrieved.
pub async fn d_elete_subusers_subuser_name(configuration: &configuration::Configuration, params: DEleteSubusersSubuserNameParams) -> Result<serde_json::Value, Error<DEleteSubusersSubuserNameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let subuser_name = params.subuser_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subusers/{subuser_name}", local_var_configuration.base_path, subuser_name=subuser_name);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteSubusersSubuserNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a list of all of your subusers.**  You can choose to retrieve specific subusers as well as limit the results that come back from the API.
pub async fn g_et_subusers(configuration: &configuration::Configuration, params: GEtSubusersParams) -> Result<serde_json::Value, Error<GEtSubusersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subusers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = username {
        local_var_req_builder = local_var_req_builder.query(&[("username", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtSubusersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to request the reputations for your subusers.**  Subuser sender reputations give a good idea how well a sender is doing with regards to how recipients and recipient servers react to the mail that is being received. When a bounce, spam report, or other negative action happens on a sent email, it will affect your sender rating.
pub async fn g_et_subusers_reputations(configuration: &configuration::Configuration, params: GEtSubusersReputationsParams) -> Result<serde_json::Value, Error<GEtSubusersReputationsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let usernames = params.usernames;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subusers/reputations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = usernames {
        local_var_req_builder = local_var_req_builder.query(&[("usernames", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtSubusersReputationsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to enable or disable a subuser.**
pub async fn p_atch_subusers_subuser_name(configuration: &configuration::Configuration, params: PAtchSubusersSubuserNameParams) -> Result<serde_json::Value, Error<PAtchSubusersSubuserNameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let subuser_name = params.subuser_name;
    let patch_subusers_subuser_name_request = params.patch_subusers_subuser_name_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subusers/{subuser_name}", local_var_configuration.base_path, subuser_name=subuser_name);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&patch_subusers_subuser_name_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchSubusersSubuserNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to create a new subuser.**
pub async fn p_ost_subusers(configuration: &configuration::Configuration, params: POstSubusersParams) -> Result<crate::models::SubuserPost, Error<POstSubusersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_subusers_request = params.post_subusers_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subusers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_subusers_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstSubusersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you update your subusers' assigned IP.**  Each subuser should be assigned to an IP address from which all of this subuser's mail will be sent. Often, this is the same IP as the parent account, but each subuser can have one or more of their own IP addresses as well.   More information:  * [How to request more IPs](https://sendgrid.com/docs/ui/account-and-settings/dedicated-ip-addresses/) * [Setup Reverse DNS](https://sendgrid.com/docs/ui/account-and-settings/how-to-set-up-reverse-dns/)
pub async fn p_ut_subusers_subuser_name_ips(configuration: &configuration::Configuration, params: PUtSubusersSubuserNameIpsParams) -> Result<crate::models::PutSubusersSubuserNameIps200Response, Error<PUtSubusersSubuserNameIpsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let subuser_name = params.subuser_name;
    let body = params.body;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/subusers/{subuser_name}/ips", local_var_configuration.base_path, subuser_name=subuser_name);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PUtSubusersSubuserNameIpsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

