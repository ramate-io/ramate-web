/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_ips_pools_pool_name`]
#[derive(Clone, Debug, Default)]
pub struct DEleteIpsPoolsPoolNameParams {
    /// The name of the IP pool that you want to retrieve the IP addresses for.
    pub pool_name: serde_json::Value
}

/// struct for passing parameters to the method [`d_elete_ips_pools_pool_name_ips_ip`]
#[derive(Clone, Debug, Default)]
pub struct DEleteIpsPoolsPoolNameIpsIpParams {
    /// The name of the IP pool that you are removing the IP address from.
    pub pool_name: serde_json::Value,
    /// The IP address that you wish to remove.
    pub ip: serde_json::Value
}

/// struct for passing parameters to the method [`g_et_ips_pools_pool_name`]
#[derive(Clone, Debug, Default)]
pub struct GEtIpsPoolsPoolNameParams {
    /// The name of the IP pool that you want to retrieve the IP addresses for.
    pub pool_name: serde_json::Value
}

/// struct for passing parameters to the method [`p_ost_ips_pools`]
#[derive(Clone, Debug, Default)]
pub struct POstIpsPoolsParams {
    pub post_ips_pools_request: Option<crate::models::PostIpsPoolsRequest>
}

/// struct for passing parameters to the method [`p_ost_ips_pools_pool_name_ips`]
#[derive(Clone, Debug, Default)]
pub struct POstIpsPoolsPoolNameIpsParams {
    /// The name of the IP pool you want to add the address to. If the name contains spaces, they must be URL encoded (e.g., \"Test Pool\" becomes \"Test%20Pool\").
    pub pool_name: serde_json::Value,
    pub post_ips_pools_pool_name_ips_request: Option<crate::models::PostIpsPoolsPoolNameIpsRequest>
}

/// struct for passing parameters to the method [`p_ut_ips_pools_pool_name`]
#[derive(Clone, Debug, Default)]
pub struct PUtIpsPoolsPoolNameParams {
    /// The name of the IP pool that you want to retrieve the IP addresses for.
    pub pool_name: serde_json::Value,
    pub put_ips_pools_pool_name_request: Option<crate::models::PutIpsPoolsPoolNameRequest>
}


/// struct for typed errors of method [`d_elete_ips_pools_pool_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteIpsPoolsPoolNameError {
    Status404(crate::models::DeleteIpsPoolsPoolName404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`d_elete_ips_pools_pool_name_ips_ip`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteIpsPoolsPoolNameIpsIpError {
    Status404(crate::models::DeleteIpsPoolsPoolNameIpsIp404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_ips_pools`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtIpsPoolsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_ips_pools_pool_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtIpsPoolsPoolNameError {
    Status404(crate::models::GetIpsPoolsPoolName404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_ips_pools`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstIpsPoolsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_ips_pools_pool_name_ips`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstIpsPoolsPoolNameIpsError {
    Status404(crate::models::PostIpsPoolsPoolNameIps404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ut_ips_pools_pool_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PUtIpsPoolsPoolNameError {
    Status404(crate::models::PutIpsPoolsPoolName404Response),
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to delete an IP pool.**
pub async fn d_elete_ips_pools_pool_name(configuration: &configuration::Configuration, params: DEleteIpsPoolsPoolNameParams) -> Result<serde_json::Value, Error<DEleteIpsPoolsPoolNameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pool_name = params.pool_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/pools/{pool_name}", local_var_configuration.base_path, pool_name=pool_name);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteIpsPoolsPoolNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to remove an IP address from an IP pool.**
pub async fn d_elete_ips_pools_pool_name_ips_ip(configuration: &configuration::Configuration, params: DEleteIpsPoolsPoolNameIpsIpParams) -> Result<serde_json::Value, Error<DEleteIpsPoolsPoolNameIpsIpError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pool_name = params.pool_name;
    let ip = params.ip;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/pools/{pool_name}/ips/{ip}", local_var_configuration.base_path, pool_name=pool_name, ip=ip);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteIpsPoolsPoolNameIpsIpError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to get all of your IP pools.**
pub async fn g_et_ips_pools(configuration: &configuration::Configuration) -> Result<serde_json::Value, Error<GEtIpsPoolsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/pools", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtIpsPoolsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to get all of the IP addresses that are in a specific IP pool.**
pub async fn g_et_ips_pools_pool_name(configuration: &configuration::Configuration, params: GEtIpsPoolsPoolNameParams) -> Result<crate::models::GetIpsPoolsPoolName200Response, Error<GEtIpsPoolsPoolNameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pool_name = params.pool_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/pools/{pool_name}", local_var_configuration.base_path, pool_name=pool_name);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtIpsPoolsPoolNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to create an IP pool.**  Before you can create an IP pool, you need to activate the IP in your SendGrid account:   1. Log into your SendGrid account.   1. Navigate to **Settings** and then select **IP Addresses**.   1. Find the IP address you want to activate and then click **Edit**.   1. Check **Allow my account to send mail using this IP address**. 1. Click **Save**.
pub async fn p_ost_ips_pools(configuration: &configuration::Configuration, params: POstIpsPoolsParams) -> Result<crate::models::IpPoolResponse, Error<POstIpsPoolsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_ips_pools_request = params.post_ips_pools_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/pools", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_ips_pools_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstIpsPoolsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to add an IP address to an IP pool.**  You can add the same IP address to multiple pools. It may take up to 60 seconds for your IP address to be added to a pool after your request is made.  Before you can add an IP to a pool, you need to activate it in your SendGrid account:  1. Log into your SendGrid account.   1. Navigate to **Settings** and then select **IP Addresses**.   1. Find the IP address you want to activate and then click **Edit**.   1. Check **Allow my account to send mail using this IP address**. 1. Click **Save**.  You can retrieve all of your available IP addresses from the \"Retrieve all IP addresses\" endpoint.
pub async fn p_ost_ips_pools_pool_name_ips(configuration: &configuration::Configuration, params: POstIpsPoolsPoolNameIpsParams) -> Result<crate::models::PostIpsPoolsPoolNameIps201Response, Error<POstIpsPoolsPoolNameIpsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pool_name = params.pool_name;
    let post_ips_pools_pool_name_ips_request = params.post_ips_pools_pool_name_ips_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/pools/{pool_name}/ips", local_var_configuration.base_path, pool_name=pool_name);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_ips_pools_pool_name_ips_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstIpsPoolsPoolNameIpsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to update the name of an IP pool.**
pub async fn p_ut_ips_pools_pool_name(configuration: &configuration::Configuration, params: PUtIpsPoolsPoolNameParams) -> Result<crate::models::IpPoolResponse, Error<PUtIpsPoolsPoolNameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let pool_name = params.pool_name;
    let put_ips_pools_pool_name_request = params.put_ips_pools_pool_name_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/pools/{pool_name}", local_var_configuration.base_path, pool_name=pool_name);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&put_ips_pools_pool_name_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PUtIpsPoolsPoolNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

