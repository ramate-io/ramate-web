/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_whitelabel_links_id`]
#[derive(Clone, Debug, Default)]
pub struct DEleteWhitelabelLinksIdParams {
    /// The ID of the branded link you want to retrieve.
    pub id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`d_elete_whitelabel_links_subuser`]
#[derive(Clone, Debug, Default)]
pub struct DEleteWhitelabelLinksSubuserParams {
    /// The username of the subuser account that you want to disassociate a branded link from.
    pub username: serde_json::Value
}

/// struct for passing parameters to the method [`g_et_whitelabel_links`]
#[derive(Clone, Debug, Default)]
pub struct GEtWhitelabelLinksParams {
    /// Limits the number of results returned per page.
    pub limit: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_whitelabel_links_default`]
#[derive(Clone, Debug, Default)]
pub struct GEtWhitelabelLinksDefaultParams {
    /// The domain to match against when finding the default branded link.
    pub domain: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_whitelabel_links_id`]
#[derive(Clone, Debug, Default)]
pub struct GEtWhitelabelLinksIdParams {
    /// The ID of the branded link you want to retrieve.
    pub id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_whitelabel_links_subuser`]
#[derive(Clone, Debug, Default)]
pub struct GEtWhitelabelLinksSubuserParams {
    /// The username of the subuser to retrieve associated branded links for.
    pub username: serde_json::Value
}

/// struct for passing parameters to the method [`p_atch_whitelabel_links_id`]
#[derive(Clone, Debug, Default)]
pub struct PAtchWhitelabelLinksIdParams {
    /// The ID of the branded link you want to retrieve.
    pub id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>,
    pub patch_whitelabel_links_id_request: Option<crate::models::PatchWhitelabelLinksIdRequest>
}

/// struct for passing parameters to the method [`p_ost_whitelabel_links`]
#[derive(Clone, Debug, Default)]
pub struct POstWhitelabelLinksParams {
    pub on_behalf_of: Option<serde_json::Value>,
    pub post_whitelabel_links_request: Option<crate::models::PostWhitelabelLinksRequest>
}

/// struct for passing parameters to the method [`p_ost_whitelabel_links_id_validate`]
#[derive(Clone, Debug, Default)]
pub struct POstWhitelabelLinksIdValidateParams {
    /// The ID of the branded link that you want to validate.
    pub id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_ost_whitelabel_links_link_id_subuser`]
#[derive(Clone, Debug, Default)]
pub struct POstWhitelabelLinksLinkIdSubuserParams {
    /// The ID of the branded link you want to associate.
    pub link_id: serde_json::Value,
    pub post_whitelabel_links_link_id_subuser_request: Option<crate::models::PostWhitelabelLinksLinkIdSubuserRequest>
}


/// struct for typed errors of method [`d_elete_whitelabel_links_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteWhitelabelLinksIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`d_elete_whitelabel_links_subuser`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteWhitelabelLinksSubuserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_whitelabel_links`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtWhitelabelLinksError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_whitelabel_links_default`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtWhitelabelLinksDefaultError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_whitelabel_links_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtWhitelabelLinksIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_whitelabel_links_subuser`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtWhitelabelLinksSubuserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_whitelabel_links_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchWhitelabelLinksIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_whitelabel_links`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstWhitelabelLinksError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_whitelabel_links_id_validate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstWhitelabelLinksIdValidateError {
    Status500(crate::models::PostWhitelabelLinksIdValidate500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_whitelabel_links_link_id_subuser`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstWhitelabelLinksLinkIdSubuserError {
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to delete a branded link.**  Your request will receive a response with a 204 status code if the deletion was successful. The call does not return the link's details, so if you wish to record these make sure you call the  \"Retrieve a branded link\" endpoint *before* you request its deletion.  You can submit this request as one of your subusers if you include their ID in the `on-behalf-of` header in the request.
pub async fn d_elete_whitelabel_links_id(configuration: &configuration::Configuration, params: DEleteWhitelabelLinksIdParams) -> Result<serde_json::Value, Error<DEleteWhitelabelLinksIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteWhitelabelLinksIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to take a branded link away from a subuser.**  Link branding can be associated with subusers from the parent account. This functionality allows subusers to send mail using their parent's link branding. To associate link branding, the parent account must first create a branded link and validate it. The parent may then associate that branded link with a subuser via the API or the [Subuser Management page of the Twilio SendGrid App](https://app.sendgrid.com/settings/subusers).  Your request will receive a response with a 204 status code if the disassociation was successful.
pub async fn d_elete_whitelabel_links_subuser(configuration: &configuration::Configuration, params: DEleteWhitelabelLinksSubuserParams) -> Result<serde_json::Value, Error<DEleteWhitelabelLinksSubuserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links/subuser", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("username", &username.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteWhitelabelLinksSubuserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve all branded links**.  You can submit this request as one of your subusers if you include their ID in the `on-behalf-of` header in the request.
pub async fn g_et_whitelabel_links(configuration: &configuration::Configuration, params: GEtWhitelabelLinksParams) -> Result<serde_json::Value, Error<GEtWhitelabelLinksError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let limit = params.limit;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtWhitelabelLinksError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve the default branded link.**  The default branded link is the actual URL to be used when sending messages. If you have more than one branded link, the default is determined by the following order:  * The validated branded link marked as `default` (set when you call the \"Create a branded link\" endpoint or by calling the \"Update a branded link\" endpoint on an existing link) * Legacy branded links (migrated from the whitelabel wizard) * Default SendGrid-branded links (i.e., `100.ct.sendgrid.net`)  You can submit this request as one of your subusers if you include their ID in the `on-behalf-of` header in the request.
pub async fn g_et_whitelabel_links_default(configuration: &configuration::Configuration, params: GEtWhitelabelLinksDefaultParams) -> Result<crate::models::LinkBranding200Response, Error<GEtWhitelabelLinksDefaultError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let domain = params.domain;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links/default", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = domain {
        local_var_req_builder = local_var_req_builder.query(&[("domain", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtWhitelabelLinksDefaultError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a specific branded link by providing its ID.**  You can submit this request as one of your subusers if you include their ID in the `on-behalf-of` header in the request.
pub async fn g_et_whitelabel_links_id(configuration: &configuration::Configuration, params: GEtWhitelabelLinksIdParams) -> Result<crate::models::LinkBranding200Response, Error<GEtWhitelabelLinksIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtWhitelabelLinksIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve the branded link associated with a subuser.**  Link branding can be associated with subusers from the parent account. This functionality allows subusers to send mail using their parent's link branding. To associate link branding, the parent account must first create a branded link and then validate it. The parent may then associate that branded link with a subuser via the API or the [Subuser Management page of the Twilio SendGrid App](https://app.sendgrid.com/settings/subusers).
pub async fn g_et_whitelabel_links_subuser(configuration: &configuration::Configuration, params: GEtWhitelabelLinksSubuserParams) -> Result<crate::models::LinkBranding200Response, Error<GEtWhitelabelLinksSubuserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links/subuser", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("username", &username.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtWhitelabelLinksSubuserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to update a specific branded link. You can use this endpoint to change a branded link's default status.**  You can submit this request as one of your subusers if you include their ID in the `on-behalf-of` header in the request.
pub async fn p_atch_whitelabel_links_id(configuration: &configuration::Configuration, params: PAtchWhitelabelLinksIdParams) -> Result<crate::models::LinkBranding200Response, Error<PAtchWhitelabelLinksIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let on_behalf_of = params.on_behalf_of;
    let patch_whitelabel_links_id_request = params.patch_whitelabel_links_id_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&patch_whitelabel_links_id_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchWhitelabelLinksIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to create a new branded link.**  To create the link branding, supply the root domain and, optionally, the subdomain — these go into separate fields in your request body. The root domain should match your FROM email address. If you provide a  subdomain, it must be different from the subdomain you used for authenticating your domain.  You can submit this request as one of your subusers if you include their ID in the `on-behalf-of` header in the request.
pub async fn p_ost_whitelabel_links(configuration: &configuration::Configuration, params: POstWhitelabelLinksParams) -> Result<crate::models::LinkBranding200Response, Error<POstWhitelabelLinksError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;
    let post_whitelabel_links_request = params.post_whitelabel_links_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_whitelabel_links_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstWhitelabelLinksError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to validate a branded link.**  You can submit this request as one of your subusers if you include their ID in the `on-behalf-of` header in the request.
pub async fn p_ost_whitelabel_links_id_validate(configuration: &configuration::Configuration, params: POstWhitelabelLinksIdValidateParams) -> Result<crate::models::PostWhitelabelLinksIdValidate200Response, Error<POstWhitelabelLinksIdValidateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links/{id}/validate", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstWhitelabelLinksIdValidateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to associate a branded link with a subuser account.**  Link branding can be associated with subusers from the parent account. This functionality allows subusers to send mail using their parent's link branding. To associate link branding, the parent account must first create a branded link and validate it. The parent may then associate that branded link with a subuser via the API or the [Subuser Management page of the Twilio SendGrid App](https://app.sendgrid.com/settings/subusers).
pub async fn p_ost_whitelabel_links_link_id_subuser(configuration: &configuration::Configuration, params: POstWhitelabelLinksLinkIdSubuserParams) -> Result<crate::models::LinkBranding200Response, Error<POstWhitelabelLinksLinkIdSubuserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let link_id = params.link_id;
    let post_whitelabel_links_link_id_subuser_request = params.post_whitelabel_links_link_id_subuser_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/links/{link_id}/subuser", local_var_configuration.base_path, link_id=link_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_whitelabel_links_link_id_subuser_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstWhitelabelLinksLinkIdSubuserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

