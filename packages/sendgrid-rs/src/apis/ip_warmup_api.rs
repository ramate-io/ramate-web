/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_ips_warmup_ip_address`]
#[derive(Clone, Debug, Default)]
pub struct DEleteIpsWarmupIpAddressParams {
    /// The IP address that you want to retrieve the warmup status for.
    pub ip_address: serde_json::Value
}

/// struct for passing parameters to the method [`g_et_ips_warmup_ip_address`]
#[derive(Clone, Debug, Default)]
pub struct GEtIpsWarmupIpAddressParams {
    /// The IP address that you want to retrieve the warmup status for.
    pub ip_address: serde_json::Value
}

/// struct for passing parameters to the method [`p_ost_ips_warmup`]
#[derive(Clone, Debug, Default)]
pub struct POstIpsWarmupParams {
    pub post_ips_warmup_request: Option<crate::models::PostIpsWarmupRequest>
}


/// struct for typed errors of method [`d_elete_ips_warmup_ip_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteIpsWarmupIpAddressError {
    Status404(crate::models::DeleteIpsWarmupIpAddress404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_ips_warmup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtIpsWarmupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_ips_warmup_ip_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtIpsWarmupIpAddressError {
    Status404(crate::models::GetIpsWarmupIpAddress404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_ips_warmup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstIpsWarmupError {
    Status404(crate::models::PostIpsWarmup404Response),
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to remove an IP address from warmup mode.**  Your request will return a 204 status code if the specified IP was successfully removed from warmup mode. To retrieve details of the IPâ€™s warmup status *before* removing it from warmup mode, call the  \"Retrieve the warmpup status for a specific IP address\" endpoint.
pub async fn d_elete_ips_warmup_ip_address(configuration: &configuration::Configuration, params: DEleteIpsWarmupIpAddressParams) -> Result<serde_json::Value, Error<DEleteIpsWarmupIpAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ip_address = params.ip_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/warmup/{ip_address}", local_var_configuration.base_path, ip_address=ip_address);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteIpsWarmupIpAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve all of your IP addresses that are currently warming up.**
pub async fn g_et_ips_warmup(configuration: &configuration::Configuration) -> Result<serde_json::Value, Error<GEtIpsWarmupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/warmup", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtIpsWarmupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve the warmup status for a specific IP address.**  You can retrieve all of your warming IPs using the \"Retrieve all IPs currently in warmup\" endpoint.
pub async fn g_et_ips_warmup_ip_address(configuration: &configuration::Configuration, params: GEtIpsWarmupIpAddressParams) -> Result<serde_json::Value, Error<GEtIpsWarmupIpAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ip_address = params.ip_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/warmup/{ip_address}", local_var_configuration.base_path, ip_address=ip_address);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtIpsWarmupIpAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to put an IP address into warmup mode.**
pub async fn p_ost_ips_warmup(configuration: &configuration::Configuration, params: POstIpsWarmupParams) -> Result<serde_json::Value, Error<POstIpsWarmupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_ips_warmup_request = params.post_ips_warmup_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/warmup", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_ips_warmup_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstIpsWarmupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

