/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`g_et_user_webhooks_event_settings`]
#[derive(Clone, Debug, Default)]
pub struct GEtUserWebhooksEventSettingsParams {
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_user_webhooks_event_settings_signed`]
#[derive(Clone, Debug, Default)]
pub struct GEtUserWebhooksEventSettingsSignedParams {
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_user_webhooks_parse_settings`]
#[derive(Clone, Debug, Default)]
pub struct GEtUserWebhooksParseSettingsParams {
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_user_webhooks_parse_stats`]
#[derive(Clone, Debug, Default)]
pub struct GEtUserWebhooksParseStatsParams {
    /// The starting date of the statistics you want to retrieve. Must be in the format YYYY-MM-DD
    pub start_date: serde_json::Value,
    /// The number of statistics to return on each page.
    pub limit: Option<serde_json::Value>,
    /// The number of statistics to skip.
    pub offset: Option<serde_json::Value>,
    /// How you would like the statistics to by grouped. 
    pub aggregated_by: Option<serde_json::Value>,
    /// The end date of the statistics you want to retrieve. Must be in the format YYYY-MM-DD
    pub end_date: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_atch_user_webhooks_event_settings`]
#[derive(Clone, Debug, Default)]
pub struct PAtchUserWebhooksEventSettingsParams {
    pub on_behalf_of: Option<serde_json::Value>,
    pub event_webhook_update_oauth_request: Option<crate::models::EventWebhookUpdateOauthRequest>
}

/// struct for passing parameters to the method [`p_atch_user_webhooks_event_settings_signed`]
#[derive(Clone, Debug, Default)]
pub struct PAtchUserWebhooksEventSettingsSignedParams {
    pub on_behalf_of: Option<serde_json::Value>,
    pub patch_user_webhooks_event_settings_signed_request: Option<crate::models::PatchUserWebhooksEventSettingsSignedRequest>
}

/// struct for passing parameters to the method [`p_ost_user_webhooks_event_test`]
#[derive(Clone, Debug, Default)]
pub struct POstUserWebhooksEventTestParams {
    pub on_behalf_of: Option<serde_json::Value>,
    pub post_user_webhooks_event_test_request: Option<crate::models::PostUserWebhooksEventTestRequest>
}


/// struct for typed errors of method [`g_et_user_webhooks_event_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtUserWebhooksEventSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_user_webhooks_event_settings_signed`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtUserWebhooksEventSettingsSignedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_user_webhooks_parse_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtUserWebhooksParseSettingsError {
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_user_webhooks_parse_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtUserWebhooksParseStatsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_user_webhooks_event_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchUserWebhooksEventSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_user_webhooks_event_settings_signed`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchUserWebhooksEventSettingsSignedError {
    Status400(crate::models::PatchUserWebhooksEventSettingsSigned400Response),
    Status401(crate::models::PatchUserWebhooksEventSettingsSigned400Response),
    Status500(crate::models::PatchUserWebhooksEventSettingsSigned400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_user_webhooks_event_test`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstUserWebhooksEventTestError {
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to retrieve your current event webhook settings.**  If an event type is marked as `true`, then the event webhook will include information about that event.  SendGridâ€™s Event Webhook will notify a URL of your choice via HTTP POST with information about events that occur as SendGrid processes your email.  Common uses of this data are to remove unsubscribes, react to spam reports, determine unengaged recipients, identify bounced email addresses, or create advanced analytics of your email program.
pub async fn g_et_user_webhooks_event_settings(configuration: &configuration::Configuration, params: GEtUserWebhooksEventSettingsParams) -> Result<crate::models::EventWebhookResponse, Error<GEtUserWebhooksEventSettingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/webhooks/event/settings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtUserWebhooksEventSettingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve your signed webhook's public key.**  Once you have enabled signing of the Event Webhook, you will need the public key provided to verify the signatures on requests coming from Twilio SendGrid. You can retrieve the public key from this endpoint at any time.  For more information about cryptographically signing the Event Webhook, see [Getting Started with the Event Webhook Security Features](https://sendgrid.com/docs/for-developers/tracking-events/getting-started-event-webhook-security-features).
pub async fn g_et_user_webhooks_event_settings_signed(configuration: &configuration::Configuration, params: GEtUserWebhooksEventSettingsSignedParams) -> Result<crate::models::GetUserWebhooksEventSettingsSigned200Response, Error<GEtUserWebhooksEventSettingsSignedError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/webhooks/event/settings/signed", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtUserWebhooksEventSettingsSignedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve all of your current inbound parse settings.**
pub async fn g_et_user_webhooks_parse_settings(configuration: &configuration::Configuration, params: GEtUserWebhooksParseSettingsParams) -> Result<crate::models::GetUserWebhooksParseSettings200Response, Error<GEtUserWebhooksParseSettingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/webhooks/parse/settings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtUserWebhooksParseSettingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve the statistics for your Parse Webhook useage.**  SendGrid's Inbound Parse Webhook allows you to parse the contents and attachments of incomming emails. The Parse API can then POST the parsed emails to a URL that you specify. The Inbound Parse Webhook cannot parse messages greater than 30MB in size, including all attachments.  There are a number of pre-made integrations for the SendGrid Parse Webhook which make processing events easy. You can find these integrations in the [Library Index](https://sendgrid.com/docs/Integrate/libraries.html#-Webhook-Libraries).
pub async fn g_et_user_webhooks_parse_stats(configuration: &configuration::Configuration, params: GEtUserWebhooksParseStatsParams) -> Result<serde_json::Value, Error<GEtUserWebhooksParseStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let start_date = params.start_date;
    let limit = params.limit;
    let offset = params.offset;
    let aggregated_by = params.aggregated_by;
    let end_date = params.end_date;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/webhooks/parse/stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = aggregated_by {
        local_var_req_builder = local_var_req_builder.query(&[("aggregated_by", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("start_date", &start_date.to_string())]);
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtUserWebhooksParseStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to update your current event webhook settings.**  If an event type is marked as `true`, then the event webhook will include information about that event.  SendGridâ€™s Event Webhook will notify a URL of your choice via HTTP POST with information about events that occur as SendGrid processes your email.  Common uses of this data are to remove unsubscribes, react to spam reports, determine unengaged recipients, identify bounced email addresses, or create advanced analytics of your email program.
pub async fn p_atch_user_webhooks_event_settings(configuration: &configuration::Configuration, params: PAtchUserWebhooksEventSettingsParams) -> Result<crate::models::EventWebhookResponse, Error<PAtchUserWebhooksEventSettingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;
    let event_webhook_update_oauth_request = params.event_webhook_update_oauth_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/webhooks/event/settings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&event_webhook_update_oauth_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchUserWebhooksEventSettingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to enable or disable signing of the Event Webhook.**  This endpoint takes a single boolean request parameter, `enabled`. You may either enable or disable signing of the Event Webhook using this endpoint. Once enabled, you can retrieve your public key using the `/webhooks/event/settings/signed` endpoint.  For more information about cryptographically signing the Event Webhook, see [Getting Started with the Event Webhook Security Features](https://sendgrid.com/docs/for-developers/tracking-events/getting-started-event-webhook-security-features).
pub async fn p_atch_user_webhooks_event_settings_signed(configuration: &configuration::Configuration, params: PAtchUserWebhooksEventSettingsSignedParams) -> Result<crate::models::GetUserWebhooksEventSettingsSigned200Response, Error<PAtchUserWebhooksEventSettingsSignedError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;
    let patch_user_webhooks_event_settings_signed_request = params.patch_user_webhooks_event_settings_signed_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/webhooks/event/settings/signed", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&patch_user_webhooks_event_settings_signed_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchUserWebhooksEventSettingsSignedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to test your event webhook by sending a fake event notification post to the provided URL.**  SendGridâ€™s Event Webhook will notify a URL of your choice via HTTP POST with information about events that occur as SendGrid processes your email.  Common uses of this data are to remove unsubscribes, react to spam reports, determine unengaged recipients, identify bounced email addresses, or create advanced analytics of your email program.  >**Tip**: Retry logic for this endpoint differs from other endpoints, which use a rolling 24-hour retry.  If your web server does not return a 2xx response type, we will retry a POST request until we receive a 2xx response or the maximum time of 10 minutes has expired.
pub async fn p_ost_user_webhooks_event_test(configuration: &configuration::Configuration, params: POstUserWebhooksEventTestParams) -> Result<(), Error<POstUserWebhooksEventTestError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;
    let post_user_webhooks_event_test_request = params.post_user_webhooks_event_test_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/webhooks/event/test", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_user_webhooks_event_test_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<POstUserWebhooksEventTestError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

