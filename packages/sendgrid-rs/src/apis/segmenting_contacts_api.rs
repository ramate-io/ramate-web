/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_marketing_segments_segment_id`]
#[derive(Clone, Debug, Default)]
pub struct DEleteMarketingSegmentsSegmentIdParams {
    pub segment_id: serde_json::Value
}

/// struct for passing parameters to the method [`d_elete_marketing_segments_segment_id_0`]
#[derive(Clone, Debug, Default)]
pub struct DEleteMarketingSegmentsSegmentId0Params {
    pub segment_id: serde_json::Value
}

/// struct for passing parameters to the method [`g_et_marketing_segments`]
#[derive(Clone, Debug, Default)]
pub struct GEtMarketingSegmentsParams {
    /// A comma separated list of list ids to be used when searching for segments with the specified parent_list_id, no more than 50 is allowed
    pub parent_list_ids: Option<serde_json::Value>,
    /// If set to `true` segments with an empty value of `parent_list_id` will be returned in the filter.  If the value is not present it defaults to 'false'.
    pub no_parent_list_id: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_marketing_segments_0`]
#[derive(Clone, Debug, Default)]
pub struct GEtMarketingSegments0Params {
    /// A comma separated list of list ids to be used when searching for segments with the specified parent_list_id, no more than 50 is allowed
    pub parent_list_ids: Option<serde_json::Value>,
    /// If set to `true` segments with an empty value of `parent_list_id` will be returned in the filter.  If the value is not present it defaults to 'false'.
    pub no_parent_list_id: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_marketing_segments_segment_id`]
#[derive(Clone, Debug, Default)]
pub struct GEtMarketingSegmentsSegmentIdParams {
    pub segment_id: serde_json::Value,
    /// Defaults to `false`.  Set to `true` to return the parsed SQL AST as a JSON object in the field `query_json`
    pub query_json: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_marketing_segments_segment_id_0`]
#[derive(Clone, Debug, Default)]
pub struct GEtMarketingSegmentsSegmentId0Params {
    pub segment_id: serde_json::Value,
    /// Defaults to `false`.  Set to `true` to return the parsed SQL AST as a JSON object in the field `query_json`
    pub query_json: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_atch_marketing_segments_segment_id`]
#[derive(Clone, Debug, Default)]
pub struct PAtchMarketingSegmentsSegmentIdParams {
    pub segment_id: serde_json::Value,
    pub segment_write_v2: Option<crate::models::SegmentWriteV2>
}

/// struct for passing parameters to the method [`p_atch_marketing_segments_segment_id_0`]
#[derive(Clone, Debug, Default)]
pub struct PAtchMarketingSegmentsSegmentId0Params {
    pub segment_id: serde_json::Value,
    pub segment_write_v2: Option<crate::models::SegmentWriteV2>
}

/// struct for passing parameters to the method [`p_ost_marketing_segments`]
#[derive(Clone, Debug, Default)]
pub struct POstMarketingSegmentsParams {
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_ost_marketing_segments_0`]
#[derive(Clone, Debug, Default)]
pub struct POstMarketingSegments0Params {
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_ost_marketing_segments_delete`]
#[derive(Clone, Debug, Default)]
pub struct POstMarketingSegmentsDeleteParams {
    pub post_marketing_segments_delete_request: Option<crate::models::PostMarketingSegmentsDeleteRequest>
}


/// struct for typed errors of method [`d_elete_marketing_segments_segment_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteMarketingSegmentsSegmentIdError {
    Status400(crate::models::GlobalErrorResponseSchema),
    Status401(),
    Status403(),
    Status404(crate::models::GetMarketingSegmentsSegmentId404Response),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`d_elete_marketing_segments_segment_id_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteMarketingSegmentsSegmentId0Error {
    Status400(crate::models::GlobalErrorResponseSchema),
    Status401(),
    Status403(),
    Status404(crate::models::GetMarketingSegmentsSegmentId404Response),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_marketing_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtMarketingSegmentsError {
    Status401(),
    Status403(),
    Status404(),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_marketing_segments_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtMarketingSegments0Error {
    Status401(),
    Status403(),
    Status404(),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_marketing_segments_segment_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtMarketingSegmentsSegmentIdError {
    Status401(),
    Status403(),
    Status404(crate::models::GetMarketingSegmentsSegmentId404Response),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_marketing_segments_segment_id_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtMarketingSegmentsSegmentId0Error {
    Status401(),
    Status403(),
    Status404(crate::models::GetMarketingSegmentsSegmentId404Response),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_marketing_segments_segment_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchMarketingSegmentsSegmentIdError {
    Status401(),
    Status403(),
    Status404(crate::models::GetMarketingSegmentsSegmentId404Response),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_marketing_segments_segment_id_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchMarketingSegmentsSegmentId0Error {
    Status401(),
    Status403(),
    Status404(crate::models::GetMarketingSegmentsSegmentId404Response),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_marketing_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstMarketingSegmentsError {
    Status401(),
    Status403(),
    Status404(),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_marketing_segments_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstMarketingSegments0Error {
    Status401(),
    Status403(),
    Status404(),
    Status500(crate::models::GetMarketingSegments500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_marketing_segments_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstMarketingSegmentsDeleteError {
    Status400(crate::models::PostV3Teammates400Response),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to delete a segment by `segment_id`.**  Note that deleting a segment does not delete the contacts associated with the segment by default. Contacts associated with a deleted segment will remain in your list of all contacts and any other segments they belong to.
pub async fn d_elete_marketing_segments_segment_id(configuration: &configuration::Configuration, params: DEleteMarketingSegmentsSegmentIdParams) -> Result<serde_json::Value, Error<DEleteMarketingSegmentsSegmentIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/{segment_id}", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteMarketingSegmentsSegmentIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to delete a segment by `segment_id`.**  Note that deleting a segment does not delete the contacts associated with the segment by default. Contacts associated with a deleted segment will remain in your list of all contacts and any other segments they belong to.
pub async fn d_elete_marketing_segments_segment_id_0(configuration: &configuration::Configuration, params: DEleteMarketingSegmentsSegmentId0Params) -> Result<serde_json::Value, Error<DEleteMarketingSegmentsSegmentId0Error>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/{segment_id}", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteMarketingSegmentsSegmentId0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a list of segments.**  The query param `parent_list_ids` is treated as a filter.  Any match will be returned.  0 matches will return a response code of 200 with an empty `results` array.  `parent_list_ids` | `no_parent_list_id` | `result` -----------------:|:--------------------:|:------------- empty | false | all segments values | false | segments filtered by list_ids values | true | segments filtered by list_ids and segments with no parent list_ids empty | true | segments with no parent list_ids
pub async fn g_et_marketing_segments(configuration: &configuration::Configuration, params: GEtMarketingSegmentsParams) -> Result<crate::models::GetMarketingSegments200Response, Error<GEtMarketingSegmentsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let parent_list_ids = params.parent_list_ids;
    let no_parent_list_id = params.no_parent_list_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = parent_list_ids {
        local_var_req_builder = local_var_req_builder.query(&[("parent_list_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = no_parent_list_id {
        local_var_req_builder = local_var_req_builder.query(&[("no_parent_list_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtMarketingSegmentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a list of segments.**  The query param `parent_list_ids` is treated as a filter.  Any match will be returned.  0 matches will return a response code of 200 with an empty `results` array.  `parent_list_ids` | `no_parent_list_id` | `result` -----------------:|:--------------------:|:------------- empty | false | all segments values | false | segments filtered by list_ids values | true | segments filtered by list_ids and segments with no parent list_ids empty | true | segments with no parent list_ids
pub async fn g_et_marketing_segments_0(configuration: &configuration::Configuration, params: GEtMarketingSegments0Params) -> Result<crate::models::GetMarketingSegments200Response, Error<GEtMarketingSegments0Error>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let parent_list_ids = params.parent_list_ids;
    let no_parent_list_id = params.no_parent_list_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = parent_list_ids {
        local_var_req_builder = local_var_req_builder.query(&[("parent_list_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = no_parent_list_id {
        local_var_req_builder = local_var_req_builder.query(&[("no_parent_list_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtMarketingSegments0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a single segment by ID.**
pub async fn g_et_marketing_segments_segment_id(configuration: &configuration::Configuration, params: GEtMarketingSegmentsSegmentIdParams) -> Result<serde_json::Value, Error<GEtMarketingSegmentsSegmentIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;
    let query_json = params.query_json;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/{segment_id}", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query_json {
        local_var_req_builder = local_var_req_builder.query(&[("query_json", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtMarketingSegmentsSegmentIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a single segment by ID.**
pub async fn g_et_marketing_segments_segment_id_0(configuration: &configuration::Configuration, params: GEtMarketingSegmentsSegmentId0Params) -> Result<serde_json::Value, Error<GEtMarketingSegmentsSegmentId0Error>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;
    let query_json = params.query_json;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/{segment_id}", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query_json {
        local_var_req_builder = local_var_req_builder.query(&[("query_json", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtMarketingSegmentsSegmentId0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to update a segment.**  Segment `name` needs to be unique. A user can not update a segment name to an existing one.
pub async fn p_atch_marketing_segments_segment_id(configuration: &configuration::Configuration, params: PAtchMarketingSegmentsSegmentIdParams) -> Result<serde_json::Value, Error<PAtchMarketingSegmentsSegmentIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;
    let segment_write_v2 = params.segment_write_v2;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/{segment_id}", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&segment_write_v2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchMarketingSegmentsSegmentIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to update a segment.**  Segment `name` needs to be unique. A user can not update a segment name to an existing one.
pub async fn p_atch_marketing_segments_segment_id_0(configuration: &configuration::Configuration, params: PAtchMarketingSegmentsSegmentId0Params) -> Result<serde_json::Value, Error<PAtchMarketingSegmentsSegmentId0Error>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;
    let segment_write_v2 = params.segment_write_v2;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/{segment_id}", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&segment_write_v2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchMarketingSegmentsSegmentId0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to create a segment.**
pub async fn p_ost_marketing_segments(configuration: &configuration::Configuration, params: POstMarketingSegmentsParams) -> Result<serde_json::Value, Error<POstMarketingSegmentsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let body = params.body;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstMarketingSegmentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to create a segment.**
pub async fn p_ost_marketing_segments_0(configuration: &configuration::Configuration, params: POstMarketingSegments0Params) -> Result<serde_json::Value, Error<POstMarketingSegments0Error>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let body = params.body;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstMarketingSegments0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint allows you to delete segments in bulk.  If the segments are used by automations or the segments do not exist in the database, the segment IDs that could not be deleted along with automation IDs that are associated to those segments will be returned.
pub async fn p_ost_marketing_segments_delete(configuration: &configuration::Configuration, params: POstMarketingSegmentsDeleteParams) -> Result<crate::models::PostMarketingSegmentsDelete200Response, Error<POstMarketingSegmentsDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_marketing_segments_delete_request = params.post_marketing_segments_delete_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/delete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_marketing_segments_delete_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstMarketingSegmentsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

