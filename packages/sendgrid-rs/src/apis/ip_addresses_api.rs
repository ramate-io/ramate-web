/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`g_et_ips`]
#[derive(Clone, Debug, Default)]
pub struct GEtIpsParams {
    /// The IP address to get
    pub ip: Option<serde_json::Value>,
    /// Should we exclude reverse DNS records (whitelabels)?
    pub exclude_whitelabels: Option<serde_json::Value>,
    /// The number of IPs you want returned at the same time.
    pub limit: Option<serde_json::Value>,
    /// The offset for the number of IPs that you are requesting.
    pub offset: Option<serde_json::Value>,
    /// The subuser you are requesting for.
    pub subuser: Option<serde_json::Value>,
    /// The direction to sort the results.
    pub sort_by_direction: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_ips_ip_address`]
#[derive(Clone, Debug, Default)]
pub struct GEtIpsIpAddressParams {
    /// The IP address you are retrieving the IP pools for.
    pub ip_address: serde_json::Value
}

/// struct for passing parameters to the method [`p_ost_ips`]
#[derive(Clone, Debug, Default)]
pub struct POstIpsParams {
    pub post_ips_request: Option<crate::models::PostIpsRequest>
}


/// struct for typed errors of method [`g_et_ips`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtIpsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_ips_assigned`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtIpsAssignedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_ips_ip_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtIpsIpAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_ips_remaining`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtIpsRemainingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_ips`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstIpsError {
    Status400(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to retrieve a list of all assigned and unassigned IPs.**  Response includes warm up status, pools, assigned subusers, and reverse DNS info. The start_date field corresponds to when warmup started for that IP.  A single IP address or a range of IP addresses may be dedicated to an account in order to send email for multiple domains. The reputation of this IP is based on the aggregate performance of all the senders who use it.
pub async fn g_et_ips(configuration: &configuration::Configuration, params: GEtIpsParams) -> Result<serde_json::Value, Error<GEtIpsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ip = params.ip;
    let exclude_whitelabels = params.exclude_whitelabels;
    let limit = params.limit;
    let offset = params.offset;
    let subuser = params.subuser;
    let sort_by_direction = params.sort_by_direction;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ip {
        local_var_req_builder = local_var_req_builder.query(&[("ip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_whitelabels {
        local_var_req_builder = local_var_req_builder.query(&[("exclude_whitelabels", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = subuser {
        local_var_req_builder = local_var_req_builder.query(&[("subuser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_by_direction {
        local_var_req_builder = local_var_req_builder.query(&[("sort_by_direction", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtIpsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve only assigned IP addresses.**  A single IP address or a range of IP addresses may be dedicated to an account in order to send email for multiple domains. The reputation of this IP is based on the aggregate performance of all the senders who use it.
pub async fn g_et_ips_assigned(configuration: &configuration::Configuration) -> Result<serde_json::Value, Error<GEtIpsAssignedError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/assigned", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtIpsAssignedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to see which IP pools a particular IP address has been added to.**  The same IP address can be added to multiple IP pools.  A single IP address or a range of IP addresses may be dedicated to an account in order to send email for multiple domains. The reputation of this IP is based on the aggregate performance of all the senders who use it.
pub async fn g_et_ips_ip_address(configuration: &configuration::Configuration, params: GEtIpsIpAddressParams) -> Result<crate::models::GetIpsIpAddress200Response, Error<GEtIpsIpAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ip_address = params.ip_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/{ip_address}", local_var_configuration.base_path, ip_address=ip_address);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtIpsIpAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint gets amount of IP Addresses that can still be created during a given period and the price of those IPs.**
pub async fn g_et_ips_remaining(configuration: &configuration::Configuration) -> Result<crate::models::GetIpsRemaining200Response, Error<GEtIpsRemainingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips/remaining", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtIpsRemainingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint is for adding a(n) IP Address(es) to your account.**
pub async fn p_ost_ips(configuration: &configuration::Configuration, params: POstIpsParams) -> Result<crate::models::PostIps201Response, Error<POstIpsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_ips_request = params.post_ips_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/ips", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_ips_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstIpsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

