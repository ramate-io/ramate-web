/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`get_automation_link_stat`]
#[derive(Clone, Debug, Default)]
pub struct GetAutomationLinkStatParams {
    /// The ID of the Automation you want to get click tracking stats for. 
    pub id: serde_json::Value,
    /// Automations can have multiple steps. Including `step_id` as a `group_by` metric allows further granularity of stats.
    pub group_by: Option<serde_json::Value>,
    /// Comma-separated list of `step_ids` that you want the link stats for.
    pub step_ids: Option<serde_json::Value>,
    /// The number of elements you want returned on each page.
    pub page_size: Option<serde_json::Value>,
    /// The stats endpoints are paginated. To get the next page, call the passed `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the first page. Similarly, if `_metadata.next` is not present, you're at the last page.
    pub page_token: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`get_automation_stat`]
#[derive(Clone, Debug, Default)]
pub struct GetAutomationStatParams {
    pub id: serde_json::Value,
    /// Automations can have multiple steps. Including `step_id` as a `group_by` metric allows further granularity of stats.
    pub group_by: Option<serde_json::Value>,
    /// Comma-separated list of `step_ids` that you want the link stats for.
    pub step_ids: Option<serde_json::Value>,
    /// Dictates how the stats are time-sliced. Currently, `\"total\"` and `\"day\"` are supported.
    pub aggregated_by: Option<serde_json::Value>,
    /// Format: `YYYY-MM-DD`. If this parameter is included, the stats' start date is included in the search.
    pub start_date: Option<serde_json::Value>,
    /// Format: `YYYY-MM-DD`.If this parameter is included, the stats' end date is included in the search.
    pub end_date: Option<serde_json::Value>,
    /// [IANA Area/Region](https://en.wikipedia.org/wiki/Tz_database#Names_of_time_zones) string representing the timezone in which the stats are to be presented, e.g., \"America/Chicago\".
    pub timezone: Option<serde_json::Value>,
    /// The number of elements you want returned on each page.
    pub page_size: Option<serde_json::Value>,
    /// The stats endpoints are paginated. To get the next page, call the passed `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the first page. Similarly, if `_metadata.next` is not present, you're at the last page.
    pub page_token: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`get_automations_stats_export`]
#[derive(Clone, Debug, Default)]
pub struct GetAutomationsStatsExportParams {
    /// The IDs of Automations for which to export stats.
    pub ids: Option<serde_json::Value>,
    /// The [IANA Area/Region](https://en.wikipedia.org/wiki/Tz_database#Names_of_time_zones) string representing the timezone in which the stats are to be presented; i.e. `\"America/Chicago\"`. This parameter changes the timezone format only; it does not alter which stats are returned.
    pub timezone: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`get_singlesend_link_stat`]
#[derive(Clone, Debug, Default)]
pub struct GetSinglesendLinkStatParams {
    pub id: serde_json::Value,
    /// The number of elements you want returned on each page.
    pub page_size: Option<serde_json::Value>,
    /// The stats endpoints are paginated. To get the next page, call the passed `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the first page. Similarly, if `_metadata.next` is not present, you're at the last page.
    pub page_token: Option<serde_json::Value>,
    /// A/B Single Sends have multiple variation IDs and phase IDs. Including these additional fields allows further granularity of stats by these fields.
    pub group_by: Option<serde_json::Value>,
    pub ab_variation_id: Option<serde_json::Value>,
    pub ab_phase_id: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`get_singlesend_stat`]
#[derive(Clone, Debug, Default)]
pub struct GetSinglesendStatParams {
    pub id: serde_json::Value,
    /// Dictates how the stats are time-sliced. Currently, `\"total\"` and `\"day\"` are supported.
    pub aggregated_by: Option<serde_json::Value>,
    /// Format: `YYYY-MM-DD`. If this parameter is included, the stats' start date is included in the search.
    pub start_date: Option<serde_json::Value>,
    /// Format: `YYYY-MM-DD`.If this parameter is included, the stats' end date is included in the search.
    pub end_date: Option<serde_json::Value>,
    /// [IANA Area/Region](https://en.wikipedia.org/wiki/Tz_database#Names_of_time_zones) string representing the timezone in which the stats are to be presented, e.g., \"America/Chicago\".
    pub timezone: Option<serde_json::Value>,
    /// The number of elements you want returned on each page.
    pub page_size: Option<serde_json::Value>,
    /// The stats endpoints are paginated. To get the next page, call the passed `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the first page. Similarly, if `_metadata.next` is not present, you're at the last page.
    pub page_token: Option<serde_json::Value>,
    /// A/B Single Sends have multiple variation IDs and phase IDs. Including these additional fields allows further granularity of stats by these fields.
    pub group_by: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`get_singlesend_stats_export`]
#[derive(Clone, Debug, Default)]
pub struct GetSinglesendStatsExportParams {
    /// The IDs of Single Sends for which to export stats.
    pub ids: Option<serde_json::Value>,
    /// The [IANA Area/Region](https://en.wikipedia.org/wiki/Tz_database#Names_of_time_zones) string representing the timezone in which the stats are to be presented; i.e. `\"America/Chicago\"`. This parameter changes the timezone format only; it does not alter which stats are returned.
    pub timezone: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`getall_automation_stats`]
#[derive(Clone, Debug, Default)]
pub struct GetallAutomationStatsParams {
    /// This endpoint returns all automation IDs if no `automation_ids` are specified.
    pub automation_ids: Option<serde_json::Value>,
    /// The number of elements you want returned on each page.
    pub page_size: Option<serde_json::Value>,
    /// The stats endpoints are paginated. To get the next page, call the passed `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the first page. Similarly, if `_metadata.next` is not present, you're at the last page.
    pub page_token: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`getall_singlesend_stats`]
#[derive(Clone, Debug, Default)]
pub struct GetallSinglesendStatsParams {
    /// This endpoint returns all Single Send IDs if no IDs are included in `singlesend_ids`.
    pub singlesend_ids: Option<serde_json::Value>,
    /// The number of elements you want returned on each page.
    pub page_size: Option<serde_json::Value>,
    /// The stats endpoints are paginated. To get the next page, call the passed `_metadata.next` URL. If `_metadata.prev` doesn't exist, you're at the first page. Similarly, if `_metadata.next` is not present, you're at the last page.
    pub page_token: Option<serde_json::Value>
}


/// struct for typed errors of method [`get_automation_link_stat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAutomationLinkStatError {
    Status400(),
    Status404(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_automation_stat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAutomationStatError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_automations_stats_export`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAutomationsStatsExportError {
    Status400(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_singlesend_link_stat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSinglesendLinkStatError {
    Status400(),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_singlesend_stat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSinglesendStatError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_singlesend_stats_export`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSinglesendStatsExportError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`getall_automation_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetallAutomationStatsError {
    Status400(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`getall_singlesend_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetallSinglesendStatsError {
    Status400(),
    UnknownValue(serde_json::Value),
}


/// **This endpoint lets you retrieve click-tracking stats for a single Automation**.  The stats returned list the URLs embedded in your Automation and the number of clicks each one received.  Responses are paginated. You can limit the number of responses returned per batch using the `page_size` query string parameter. The default is 50, but you specify a value between 1 and 100.  You can retrieve a specific page of responses with the `page_token` query string parameter.
pub async fn get_automation_link_stat(configuration: &configuration::Configuration, params: GetAutomationLinkStatParams) -> Result<crate::models::AutomationsLinkStatsResponse, Error<GetAutomationLinkStatError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let group_by = params.group_by;
    let step_ids = params.step_ids;
    let page_size = params.page_size;
    let page_token = params.page_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/stats/automations/{id}/links", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = group_by {
        local_var_req_builder = local_var_req_builder.query(&[("group_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = step_ids {
        local_var_req_builder = local_var_req_builder.query(&[("step_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAutomationLinkStatError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve stats for a single Automation using its ID.**  Multiple Automation IDs can be retrieved using the \"Get All Automation Stats\" endpoint. Once you have an ID, this endpoint will return detailed stats for the single automation specified.  You may constrain the stats returned using the `start_date` and `end_date` query string parameters. You can also use the `group_by` and `aggregated_by` query string parameters to further refine the stats returned.
pub async fn get_automation_stat(configuration: &configuration::Configuration, params: GetAutomationStatParams) -> Result<crate::models::AutomationsResponse, Error<GetAutomationStatError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let group_by = params.group_by;
    let step_ids = params.step_ids;
    let aggregated_by = params.aggregated_by;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let timezone = params.timezone;
    let page_size = params.page_size;
    let page_token = params.page_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/stats/automations/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = group_by {
        local_var_req_builder = local_var_req_builder.query(&[("group_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = step_ids {
        local_var_req_builder = local_var_req_builder.query(&[("step_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = aggregated_by {
        local_var_req_builder = local_var_req_builder.query(&[("aggregated_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = timezone {
        local_var_req_builder = local_var_req_builder.query(&[("timezone", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAutomationStatError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to export Automation stats as CSV data**.  You can specify one Automation or many: include as many Automation IDs as you need, separating them with commas, as the value of the `ids` query string paramter.  The data is returned as plain text response but in CSV format, so your application making the call can present the information in whatever way is most appropriate, or just save the data as a `.csv` file.
pub async fn get_automations_stats_export(configuration: &configuration::Configuration, params: GetAutomationsStatsExportParams) -> Result<serde_json::Value, Error<GetAutomationsStatsExportError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ids = params.ids;
    let timezone = params.timezone;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/stats/automations/export", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ids {
        local_var_req_builder = local_var_req_builder.query(&[("ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = timezone {
        local_var_req_builder = local_var_req_builder.query(&[("timezone", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAutomationsStatsExportError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint lets you retrieve click-tracking stats for one Single Send**.  The stats returned list the URLs embedded in the specified Single Send and the number of clicks each one received.  Responses are paginated. You can limit the number of responses returned per batch using the `page_size` query string parameter. The default is 50, but you specify a value between 1 and 100.  You can retrieve a specific page of responses with the `page_token` query string parameter.
pub async fn get_singlesend_link_stat(configuration: &configuration::Configuration, params: GetSinglesendLinkStatParams) -> Result<crate::models::SinglesendsLinkStatsResponse, Error<GetSinglesendLinkStatError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let page_size = params.page_size;
    let page_token = params.page_token;
    let group_by = params.group_by;
    let ab_variation_id = params.ab_variation_id;
    let ab_phase_id = params.ab_phase_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/stats/singlesends/{id}/links", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = group_by {
        local_var_req_builder = local_var_req_builder.query(&[("group_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ab_variation_id {
        local_var_req_builder = local_var_req_builder.query(&[("ab_variation_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ab_phase_id {
        local_var_req_builder = local_var_req_builder.query(&[("ab_phase_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSinglesendLinkStatError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve stats for an individual Single Send using a Single Send ID.**  Multiple Single Send IDs can be retrieved using the \"Get All Single Sends Stats\" endpoint. Once you have an ID, this endpoint will return detailed stats for the Single Send specified.  You may constrain the stats returned using the `start_date` and `end_date` query string parameters. You can also use the `group_by` and `aggregated_by` query string parameters to further refine the stats returned.
pub async fn get_singlesend_stat(configuration: &configuration::Configuration, params: GetSinglesendStatParams) -> Result<crate::models::SinglesendsResponse, Error<GetSinglesendStatError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let aggregated_by = params.aggregated_by;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let timezone = params.timezone;
    let page_size = params.page_size;
    let page_token = params.page_token;
    let group_by = params.group_by;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/stats/singlesends/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = aggregated_by {
        local_var_req_builder = local_var_req_builder.query(&[("aggregated_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = timezone {
        local_var_req_builder = local_var_req_builder.query(&[("timezone", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = group_by {
        local_var_req_builder = local_var_req_builder.query(&[("group_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSinglesendStatError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to export Single Send stats as .CSV data**.  You can specify one Single Send or many: include as many Single Send IDs as you need, separating them with commas, as the value of the `ids` query string paramter.  The data is returned as plain text response but in .CSV format, so your application making the call can present the information in whatever way is most appropriate, or just save the data as a .csv file.
pub async fn get_singlesend_stats_export(configuration: &configuration::Configuration, params: GetSinglesendStatsExportParams) -> Result<serde_json::Value, Error<GetSinglesendStatsExportError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ids = params.ids;
    let timezone = params.timezone;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/stats/singlesends/export", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ids {
        local_var_req_builder = local_var_req_builder.query(&[("ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = timezone {
        local_var_req_builder = local_var_req_builder.query(&[("timezone", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSinglesendStatsExportError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve stats for all your Automations.**  By default, all of your Automations will be returned, but you can specify a selection by passing in a comma-separated list of Automation IDs as the value of the query string parameter `automation_ids`.  Responses are paginated. You can limit the number of responses returned per batch using the `page_size` query string parameter. The default is 50, but you specify a value between 1 and 100.  You can retrieve a specific page of responses with the `page_token` query string parameter.
pub async fn getall_automation_stats(configuration: &configuration::Configuration, params: GetallAutomationStatsParams) -> Result<crate::models::AutomationsResponse, Error<GetallAutomationStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let automation_ids = params.automation_ids;
    let page_size = params.page_size;
    let page_token = params.page_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/stats/automations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = automation_ids {
        local_var_req_builder = local_var_req_builder.query(&[("automation_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetallAutomationStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve stats for all your Single Sends.**  By default, all of your Single Sends will be returned, but you can specify a selection by passing in a comma-separated list of Single Send IDs as the value of the query string parameter `singlesend_ids`.  Responses are paginated. You can limit the number of responses returned per batch using the `page_size` query string parameter. The default is 50, but you specify a value between 1 and 100.  You can retrieve a specific page of responses with the `page_token` query string parameter.
pub async fn getall_singlesend_stats(configuration: &configuration::Configuration, params: GetallSinglesendStatsParams) -> Result<crate::models::SinglesendsResponse, Error<GetallSinglesendStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let singlesend_ids = params.singlesend_ids;
    let page_size = params.page_size;
    let page_token = params.page_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/stats/singlesends", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = singlesend_ids {
        local_var_req_builder = local_var_req_builder.query(&[("singlesend_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetallSinglesendStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

