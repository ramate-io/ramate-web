/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_asm_groups_group_id_suppressions_email`]
#[derive(Clone, Debug, Default)]
pub struct DEleteAsmGroupsGroupIdSuppressionsEmailParams {
    /// The id of the suppression group that you are removing an email address from.
    pub group_id: serde_json::Value,
    /// The email address that you want to remove from the suppression group.
    pub email: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_asm_groups_group_id_suppressions`]
#[derive(Clone, Debug, Default)]
pub struct GEtAsmGroupsGroupIdSuppressionsParams {
    /// The id of the unsubscribe group that you are adding suppressions to.
    pub group_id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_asm_suppressions`]
#[derive(Clone, Debug, Default)]
pub struct GEtAsmSuppressionsParams {
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_asm_suppressions_email`]
#[derive(Clone, Debug, Default)]
pub struct GEtAsmSuppressionsEmailParams {
    /// The email address that you want to search suppression groups for.
    pub email: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_ost_asm_groups_group_id_suppressions`]
#[derive(Clone, Debug, Default)]
pub struct POstAsmGroupsGroupIdSuppressionsParams {
    /// The id of the unsubscribe group that you are adding suppressions to.
    pub group_id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>,
    pub suppressions_request: Option<crate::models::SuppressionsRequest>
}

/// struct for passing parameters to the method [`p_ost_asm_groups_group_id_suppressions_search`]
#[derive(Clone, Debug, Default)]
pub struct POstAsmGroupsGroupIdSuppressionsSearchParams {
    /// The ID of the suppression group that you would like to search.
    pub group_id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>,
    pub suppressions_request: Option<crate::models::SuppressionsRequest>
}


/// struct for typed errors of method [`d_elete_asm_groups_group_id_suppressions_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteAsmGroupsGroupIdSuppressionsEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_asm_groups_group_id_suppressions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtAsmGroupsGroupIdSuppressionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_asm_suppressions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtAsmSuppressionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_asm_suppressions_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtAsmSuppressionsEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_asm_groups_group_id_suppressions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstAsmGroupsGroupIdSuppressionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_asm_groups_group_id_suppressions_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstAsmGroupsGroupIdSuppressionsSearchError {
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to remove a suppressed email address from the given suppression group.**  Removing an address will remove the suppression, meaning email will once again be sent to the previously suppressed addresses. This should be avoided unless a recipient indicates they wish to receive email from you again. You can use our [bypass filters](https://sendgrid.com/docs/ui/sending-email/index-suppressions/#bypass-suppressions) to deliver messages to otherwise suppressed addresses when exceptions are required.
pub async fn d_elete_asm_groups_group_id_suppressions_email(configuration: &configuration::Configuration, params: DEleteAsmGroupsGroupIdSuppressionsEmailParams) -> Result<serde_json::Value, Error<DEleteAsmGroupsGroupIdSuppressionsEmailError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;
    let email = params.email;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/asm/groups/{group_id}/suppressions/{email}", local_var_configuration.base_path, group_id=group_id, email=email);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteAsmGroupsGroupIdSuppressionsEmailError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve all suppressed email addresses belonging to the given group.**
pub async fn g_et_asm_groups_group_id_suppressions(configuration: &configuration::Configuration, params: GEtAsmGroupsGroupIdSuppressionsParams) -> Result<serde_json::Value, Error<GEtAsmGroupsGroupIdSuppressionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/asm/groups/{group_id}/suppressions", local_var_configuration.base_path, group_id=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtAsmGroupsGroupIdSuppressionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a list of all suppressions.**
pub async fn g_et_asm_suppressions(configuration: &configuration::Configuration, params: GEtAsmSuppressionsParams) -> Result<serde_json::Value, Error<GEtAsmSuppressionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/asm/suppressions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtAsmSuppressionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint returns a list of all groups from which the given email address has been unsubscribed.**
pub async fn g_et_asm_suppressions_email(configuration: &configuration::Configuration, params: GEtAsmSuppressionsEmailParams) -> Result<crate::models::GetAsmSuppressionsEmail200Response, Error<GEtAsmSuppressionsEmailError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let email = params.email;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/asm/suppressions/{email}", local_var_configuration.base_path, email=email);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtAsmSuppressionsEmailError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to add email addresses to an unsubscribe group.**  If you attempt to add suppressions to a group that has been deleted or does not exist, the suppressions will be added to the global suppressions list.
pub async fn p_ost_asm_groups_group_id_suppressions(configuration: &configuration::Configuration, params: POstAsmGroupsGroupIdSuppressionsParams) -> Result<crate::models::PostAsmGroupsGroupIdSuppressions201Response, Error<POstAsmGroupsGroupIdSuppressionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;
    let on_behalf_of = params.on_behalf_of;
    let suppressions_request = params.suppressions_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/asm/groups/{group_id}/suppressions", local_var_configuration.base_path, group_id=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&suppressions_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstAsmGroupsGroupIdSuppressionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to search a suppression group for multiple suppressions.**  When given a list of email addresses and a group ID, this endpoint will only return the email addresses that have been unsubscribed from the given group.
pub async fn p_ost_asm_groups_group_id_suppressions_search(configuration: &configuration::Configuration, params: POstAsmGroupsGroupIdSuppressionsSearchParams) -> Result<serde_json::Value, Error<POstAsmGroupsGroupIdSuppressionsSearchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let group_id = params.group_id;
    let on_behalf_of = params.on_behalf_of;
    let suppressions_request = params.suppressions_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/asm/groups/{group_id}/suppressions/search", local_var_configuration.base_path, group_id=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&suppressions_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstAsmGroupsGroupIdSuppressionsSearchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

