/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_eletemc_field_definitions_custom_field_id`]
#[derive(Clone, Debug, Default)]
pub struct DEletemcFieldDefinitionsCustomFieldIdParams {
    pub custom_field_id: serde_json::Value
}

/// struct for passing parameters to the method [`p_atchmc_field_definitions_custom_field_id`]
#[derive(Clone, Debug, Default)]
pub struct PAtchmcFieldDefinitionsCustomFieldIdParams {
    pub custom_field_id: serde_json::Value,
    pub patch_mc_field_definitions_custom_field_id_request: Option<crate::models::PatchMcFieldDefinitionsCustomFieldIdRequest>
}

/// struct for passing parameters to the method [`p_ostmc_field_definitions`]
#[derive(Clone, Debug, Default)]
pub struct POstmcFieldDefinitionsParams {
    pub post_mc_field_definitions_request: Option<crate::models::PostMcFieldDefinitionsRequest>
}


/// struct for typed errors of method [`d_eletemc_field_definitions_custom_field_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEletemcFieldDefinitionsCustomFieldIdError {
    Status404(crate::models::PutMcContactsImports400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_etmc_field_definitions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtmcFieldDefinitionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atchmc_field_definitions_custom_field_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchmcFieldDefinitionsCustomFieldIdError {
    Status400(crate::models::PutMcContactsImports400Response),
    Status404(crate::models::PutMcContactsImports400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ostmc_field_definitions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstmcFieldDefinitionsError {
    Status400(crate::models::PutMcContactsImports400Response),
    UnknownValue(serde_json::Value),
}


/// **This endpoint deletes a defined Custom Field.**  You cand delete only Custom Fields; Reserved Fields cannot be deleted.
pub async fn d_eletemc_field_definitions_custom_field_id(configuration: &configuration::Configuration, params: DEletemcFieldDefinitionsCustomFieldIdParams) -> Result<(), Error<DEletemcFieldDefinitionsCustomFieldIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let custom_field_id = params.custom_field_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/field_definitions/{custom_field_id}", local_var_configuration.base_path, custom_field_id=custom_field_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DEletemcFieldDefinitionsCustomFieldIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint retrieves all defined Custom Fields and Reserved Fields.**
pub async fn g_etmc_field_definitions(configuration: &configuration::Configuration) -> Result<crate::models::GetMcFieldDefinitions200Response, Error<GEtmcFieldDefinitionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/field_definitions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtmcFieldDefinitionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endopoint allows you to update a defined Custom Field.**  Only your Custom fields can be modified; Reserved Fields cannot be updated.
pub async fn p_atchmc_field_definitions_custom_field_id(configuration: &configuration::Configuration, params: PAtchmcFieldDefinitionsCustomFieldIdParams) -> Result<serde_json::Value, Error<PAtchmcFieldDefinitionsCustomFieldIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let custom_field_id = params.custom_field_id;
    let patch_mc_field_definitions_custom_field_id_request = params.patch_mc_field_definitions_custom_field_id_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/field_definitions/{custom_field_id}", local_var_configuration.base_path, custom_field_id=custom_field_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&patch_mc_field_definitions_custom_field_id_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchmcFieldDefinitionsCustomFieldIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint creates a new custom field definition.**  Custom field definitions are created with the given `name` and `field_type`. Although field names are stored in a case-sensitive manner, all field names must be case-insensitively unique. This means you may create a field named `CamelCase` or `camelcase`, but not both. Additionally, a Custom Field name cannot collide with any Reserved Field names. You should save the returned `id` value in order to update or delete the field at a later date. You can have up to 120 custom fields.  The custom field name should be created using only alphanumeric characters (A-Z and 0-9) and underscores (\\_). Custom fields can only begin with letters  A-Z or underscores (_). The field type can be date, text, or number fields. The field type is important for creating segments from your contact database.  **Note: Creating a custom field that begins with a number will cause issues with sending in Marketing Campaigns.**
pub async fn p_ostmc_field_definitions(configuration: &configuration::Configuration, params: POstmcFieldDefinitionsParams) -> Result<serde_json::Value, Error<POstmcFieldDefinitionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_mc_field_definitions_request = params.post_mc_field_definitions_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/field_definitions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_mc_field_definitions_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstmcFieldDefinitionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

