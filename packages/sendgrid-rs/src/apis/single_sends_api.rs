/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_marketing_singlesends`]
#[derive(Clone, Debug, Default)]
pub struct DEleteMarketingSinglesendsParams {
    /// Single Send IDs to delete
    pub ids: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`d_elete_marketing_singlesends_id`]
#[derive(Clone, Debug, Default)]
pub struct DEleteMarketingSinglesendsIdParams {
    pub id: serde_json::Value
}

/// struct for passing parameters to the method [`d_elete_marketing_singlesends_id_schedule`]
#[derive(Clone, Debug, Default)]
pub struct DEleteMarketingSinglesendsIdScheduleParams {
    pub id: serde_json::Value
}

/// struct for passing parameters to the method [`g_et_marketing_singlesends`]
#[derive(Clone, Debug, Default)]
pub struct GEtMarketingSinglesendsParams {
    pub page_size: Option<serde_json::Value>,
    pub page_token: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_marketing_singlesends_id`]
#[derive(Clone, Debug, Default)]
pub struct GEtMarketingSinglesendsIdParams {
    pub id: serde_json::Value
}

/// struct for passing parameters to the method [`p_atch_marketing_singlesends_id`]
#[derive(Clone, Debug, Default)]
pub struct PAtchMarketingSinglesendsIdParams {
    pub id: serde_json::Value,
    pub singlesend_request: Option<crate::models::SinglesendRequest>
}

/// struct for passing parameters to the method [`p_ost_marketing_singlesends`]
#[derive(Clone, Debug, Default)]
pub struct POstMarketingSinglesendsParams {
    pub singlesend_request: Option<crate::models::SinglesendRequest>
}

/// struct for passing parameters to the method [`p_ost_marketing_singlesends_id`]
#[derive(Clone, Debug, Default)]
pub struct POstMarketingSinglesendsIdParams {
    pub id: serde_json::Value,
    pub post_marketing_singlesends_id_request: Option<crate::models::PostMarketingSinglesendsIdRequest>
}

/// struct for passing parameters to the method [`p_ost_marketing_singlesends_search`]
#[derive(Clone, Debug, Default)]
pub struct POstMarketingSinglesendsSearchParams {
    pub page_size: Option<serde_json::Value>,
    pub page_token: Option<serde_json::Value>,
    pub singlesend_search: Option<crate::models::SinglesendSearch>
}

/// struct for passing parameters to the method [`p_ut_marketing_singlesends_id_schedule`]
#[derive(Clone, Debug, Default)]
pub struct PUtMarketingSinglesendsIdScheduleParams {
    pub id: serde_json::Value,
    pub put_marketing_singlesends_id_schedule_request: Option<crate::models::PutMarketingSinglesendsIdScheduleRequest>
}


/// struct for typed errors of method [`d_elete_marketing_singlesends`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteMarketingSinglesendsError {
    Status404(crate::models::GetMarketingSinglesends500Response),
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`d_elete_marketing_singlesends_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteMarketingSinglesendsIdError {
    Status404(crate::models::GetMarketingSinglesends500Response),
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`d_elete_marketing_singlesends_id_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteMarketingSinglesendsIdScheduleError {
    Status404(crate::models::GetMarketingSinglesends500Response),
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_marketing_singlesends`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtMarketingSinglesendsError {
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_marketing_singlesends_categories`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtMarketingSinglesendsCategoriesError {
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_marketing_singlesends_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtMarketingSinglesendsIdError {
    Status404(crate::models::GetMarketingSinglesends500Response),
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_marketing_singlesends_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchMarketingSinglesendsIdError {
    Status400(crate::models::GetMarketingSinglesends500Response),
    Status404(crate::models::GetMarketingSinglesends500Response),
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_marketing_singlesends`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstMarketingSinglesendsError {
    Status400(crate::models::GetMarketingSinglesends500Response),
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_marketing_singlesends_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstMarketingSinglesendsIdError {
    Status404(crate::models::GetMarketingSinglesends500Response),
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_marketing_singlesends_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstMarketingSinglesendsSearchError {
    Status404(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ut_marketing_singlesends_id_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PUtMarketingSinglesendsIdScheduleError {
    Status404(crate::models::GetMarketingSinglesends500Response),
    Status500(crate::models::GetMarketingSinglesends500Response),
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to delete multiple Single Sends using an array of Single Sends IDs.**  To first retrieve all your Single Sends' IDs, you can make a GET request to the `/marketing/singlensends` endpoint.  Please note that a DELETE request is permanent, and your Single Sends will not be recoverable after deletion.
pub async fn d_elete_marketing_singlesends(configuration: &configuration::Configuration, params: DEleteMarketingSinglesendsParams) -> Result<(), Error<DEleteMarketingSinglesendsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ids = params.ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ids {
        local_var_req_builder = local_var_req_builder.query(&[("ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DEleteMarketingSinglesendsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to delete one Single Send using a Single Send ID.**  To first retrieve all your Single Sends' IDs, you can make a GET request to the `/marketing/singlensends` endpoint.  Please note that a `DELETE` request is permanent, and your Single Send will not be recoverable after deletion.
pub async fn d_elete_marketing_singlesends_id(configuration: &configuration::Configuration, params: DEleteMarketingSinglesendsIdParams) -> Result<(), Error<DEleteMarketingSinglesendsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DEleteMarketingSinglesendsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to cancel a scheduled Single Send using a Single Send ID.**  Making a DELETE request to this endpoint will cancel the scheduled sending of a Single Send. The request will not delete the Single Send itself. Deleting a Single Send can be done by passing a DELETE request to `/marketing/singlesends/{id}`.
pub async fn d_elete_marketing_singlesends_id_schedule(configuration: &configuration::Configuration, params: DEleteMarketingSinglesendsIdScheduleParams) -> Result<crate::models::SinglesendSchedule, Error<DEleteMarketingSinglesendsIdScheduleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends/{id}/schedule", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteMarketingSinglesendsIdScheduleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve all your Single Sends.**  Returns all of your Single Sends with condensed details about each, including the Single Sends' IDs. For more details about an individual Single Send, pass the Single Send's ID to the `/marketing/singlesends/{id}` endpoint.
pub async fn g_et_marketing_singlesends(configuration: &configuration::Configuration, params: GEtMarketingSinglesendsParams) -> Result<crate::models::GetMarketingSinglesends200Response, Error<GEtMarketingSinglesendsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;
    let page_token = params.page_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtMarketingSinglesendsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve all the categories associated with your Single Sends.**  This endpoint will return your latest 1,000 categories.
pub async fn g_et_marketing_singlesends_categories(configuration: &configuration::Configuration) -> Result<crate::models::GetMarketingSinglesendsCategories200Response, Error<GEtMarketingSinglesendsCategoriesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends/categories", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtMarketingSinglesendsCategoriesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve details about one Single Send using a Single Send ID.**  You can retrieve all of your Single Sends by making a GET request to the `/marketing/singlesends` endpoint.
pub async fn g_et_marketing_singlesends_id(configuration: &configuration::Configuration, params: GEtMarketingSinglesendsIdParams) -> Result<serde_json::Value, Error<GEtMarketingSinglesendsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtMarketingSinglesendsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to update a Single Send using a Single Send ID.**  You only need to pass the fields you want to update. Any blank/missing fields will remain unaltered.
pub async fn p_atch_marketing_singlesends_id(configuration: &configuration::Configuration, params: PAtchMarketingSinglesendsIdParams) -> Result<serde_json::Value, Error<PAtchMarketingSinglesendsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let singlesend_request = params.singlesend_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&singlesend_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchMarketingSinglesendsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to create a new Single Send.**  Please note that if you are migrating from the previous version of Single Sends, you no longer need to pass a template ID with your request to this endpoint. Instead, you will pass all template data in the `email_config` object.
pub async fn p_ost_marketing_singlesends(configuration: &configuration::Configuration, params: POstMarketingSinglesendsParams) -> Result<serde_json::Value, Error<POstMarketingSinglesendsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let singlesend_request = params.singlesend_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&singlesend_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstMarketingSinglesendsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to duplicate an existing Single Send using its Single Send ID.**  Duplicating a Single Send is useful when you want to create a Single Send but don't want to start from scratch. Once duplicated, you can update or edit the Single Send by making a PATCH request to the `/marketing/singlesends/{id}` endpoint.   If you leave the `name` field blank, your duplicate will be assigned the name of the Single Send it was copied from with the text “Copy of ” prepended to it. The `name` field length is limited to 100 characters, so the end of the new Single Send name, including “Copy of ”, will be trimmed if the name exceeds this limit.
pub async fn p_ost_marketing_singlesends_id(configuration: &configuration::Configuration, params: POstMarketingSinglesendsIdParams) -> Result<serde_json::Value, Error<POstMarketingSinglesendsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let post_marketing_singlesends_id_request = params.post_marketing_singlesends_id_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_marketing_singlesends_id_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstMarketingSinglesendsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to search for Single Sends based on specified criteria.**  You can search for Single Sends by passing a combination of values using the `name`, `status`, and `categories` request body fields.  For example, if you want to search for all Single Sends that are \"drafts\" or \"scheduled\" and also associated with the category \"shoes,\" your request body may look like the example below.  ```javascript {   \"status\": [     \"draft\",     \"scheduled\"   ],   \"categories\": [     \"shoes\"   ], } ```
pub async fn p_ost_marketing_singlesends_search(configuration: &configuration::Configuration, params: POstMarketingSinglesendsSearchParams) -> Result<crate::models::GetMarketingSinglesends200Response, Error<POstMarketingSinglesendsSearchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;
    let page_token = params.page_token;
    let singlesend_search = params.singlesend_search;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&singlesend_search);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstMarketingSinglesendsSearchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to schedule a Single Send for future delivery using a Single Send ID.**  To schedule a Single Send, you must pass a date string in ISO 8601 time format (yyyy-MM-ddTHH:mm:ssZ)  using the required `send_at` field. For example, the ISO 8601 format for 9:00 AM UTC on May 6, 2020 would be `2020-05-06T09:00:00Z`. You may also pass the string `\"now\"` to send the Single Send immediately.
pub async fn p_ut_marketing_singlesends_id_schedule(configuration: &configuration::Configuration, params: PUtMarketingSinglesendsIdScheduleParams) -> Result<crate::models::PutMarketingSinglesendsIdSchedule201Response, Error<PUtMarketingSinglesendsIdScheduleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let put_marketing_singlesends_id_schedule_request = params.put_marketing_singlesends_id_schedule_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/singlesends/{id}/schedule", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&put_marketing_singlesends_id_schedule_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PUtMarketingSinglesendsIdScheduleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

