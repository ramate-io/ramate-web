/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`g_et_segments`]
#[derive(Clone, Debug, Default)]
pub struct GEtSegmentsParams {
    /// A comma separated list up to 50 in size, to filter segments on.  Only segments that have any of these list ids as the parent list will be retrieved. This is different from the parameter of the same name used when creating a segment.
    pub parent_list_ids: Option<serde_json::Value>,
    /// If set to `true` segments with an empty value of `parent_list_id` will be returned in the filter.  If the value is not present it defaults to 'false'.
    pub no_parent_list_id: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_segments_segment_id`]
#[derive(Clone, Debug, Default)]
pub struct GEtSegmentsSegmentIdParams {
    pub segment_id: serde_json::Value,
    /// Defaults to `true`. Set to `false` to exclude the contacts_sample in the response.
    pub contacts_sample: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_atch_segments_segment_id`]
#[derive(Clone, Debug, Default)]
pub struct PAtchSegmentsSegmentIdParams {
    pub segment_id: serde_json::Value,
    pub segment_update: Option<crate::models::SegmentUpdate>
}

/// struct for passing parameters to the method [`p_ost_segments`]
#[derive(Clone, Debug, Default)]
pub struct POstSegmentsParams {
    pub segment_write_v2: Option<crate::models::SegmentWriteV2>
}


/// struct for typed errors of method [`g_et_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtSegmentsError {
    Status400(crate::models::ErrorsSegV2),
    Status404(),
    Status500(crate::models::ErrorsSegV2),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_segments_segment_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtSegmentsSegmentIdError {
    Status400(crate::models::ErrorsSegV2),
    Status500(crate::models::ErrorsSegV2),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_segments_segment_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchSegmentsSegmentIdError {
    Status400(crate::models::ErrorsSegV2),
    Status429(),
    Status500(crate::models::ErrorsSegV2),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstSegmentsError {
    Status400(crate::models::ErrorsSegV2),
    Status404(),
    Status429(),
    Status500(crate::models::ErrorsSegV2),
    UnknownValue(serde_json::Value),
}


/// The query param `parent_list_ids` is treated as a filter.  Any match will be returned.  0 matches will return a response code of 200 with an empty `results` array.  `parent_list_ids` | `no_parent_list_id` | `result` -----------------:|:--------------------:|:------------- empty | false | all segments values | false | segments filtered by list_ids values | true | segments filtered by list_ids and segments with no parent list_ids empty | true | segments with no parent list_ids
pub async fn g_et_segments(configuration: &configuration::Configuration, params: GEtSegmentsParams) -> Result<crate::models::AllSegmentsResponse, Error<GEtSegmentsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let parent_list_ids = params.parent_list_ids;
    let no_parent_list_id = params.no_parent_list_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/2.0", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = parent_list_ids {
        local_var_req_builder = local_var_req_builder.query(&[("parent_list_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = no_parent_list_id {
        local_var_req_builder = local_var_req_builder.query(&[("no_parent_list_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtSegmentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// 
pub async fn g_et_segments_segment_id(configuration: &configuration::Configuration, params: GEtSegmentsSegmentIdParams) -> Result<crate::models::SegmentResponse, Error<GEtSegmentsSegmentIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;
    let contacts_sample = params.contacts_sample;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/2.0/{segment_id}", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = contacts_sample {
        local_var_req_builder = local_var_req_builder.query(&[("contacts_sample", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtSegmentsSegmentIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Segment `name` has to be unique. A user can not create a new segment with an existing segment name.
pub async fn p_atch_segments_segment_id(configuration: &configuration::Configuration, params: PAtchSegmentsSegmentIdParams) -> Result<crate::models::SegmentResponse, Error<PAtchSegmentsSegmentIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;
    let segment_update = params.segment_update;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/2.0/{segment_id}", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&segment_update);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchSegmentsSegmentIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Segment `name` has to be unique. A user can not create a new segment with an existing segment name.
pub async fn p_ost_segments(configuration: &configuration::Configuration, params: POstSegmentsParams) -> Result<crate::models::SegmentResponse, Error<POstSegmentsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_write_v2 = params.segment_write_v2;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/segments/2.0", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&segment_write_v2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstSegmentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

