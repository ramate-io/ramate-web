/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_eletev3_scopes_requests_request_id`]
#[derive(Clone, Debug, Default)]
pub struct DEletev3ScopesRequestsRequestIdParams {
    /// The ID of the request that you want to deny.
    pub request_id: serde_json::Value
}

/// struct for passing parameters to the method [`d_eletev3_teammates_pending_token`]
#[derive(Clone, Debug, Default)]
pub struct DEletev3TeammatesPendingTokenParams {
    /// The token for the invite you want to delete.
    pub token: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`d_eletev3_teammates_username`]
#[derive(Clone, Debug, Default)]
pub struct DEletev3TeammatesUsernameParams {
    /// The username of the teammate that you want to retrieve.
    pub username: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_etv3_scopes_requests`]
#[derive(Clone, Debug, Default)]
pub struct GEtv3ScopesRequestsParams {
    /// Optional field to limit the number of results returned.
    pub limit: Option<serde_json::Value>,
    /// Optional beginning point in the list to retrieve from.
    pub offset: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_etv3_teammates`]
#[derive(Clone, Debug, Default)]
pub struct GEtv3TeammatesParams {
    /// Number of items to return
    pub limit: Option<serde_json::Value>,
    /// Paging offset
    pub offset: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_etv3_teammates_pending`]
#[derive(Clone, Debug, Default)]
pub struct GEtv3TeammatesPendingParams {
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_etv3_teammates_username`]
#[derive(Clone, Debug, Default)]
pub struct GEtv3TeammatesUsernameParams {
    /// The username of the teammate that you want to retrieve.
    pub username: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_atchv3_scopes_requests_approve_id`]
#[derive(Clone, Debug, Default)]
pub struct PAtchv3ScopesRequestsApproveIdParams {
    /// The ID of the request that you want to approve.
    pub request_id: serde_json::Value
}

/// struct for passing parameters to the method [`p_atchv3_teammates_username`]
#[derive(Clone, Debug, Default)]
pub struct PAtchv3TeammatesUsernameParams {
    /// The username of the teammate that you want to retrieve.
    pub username: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>,
    pub patch_v3_teammates_username_request: Option<crate::models::PatchV3TeammatesUsernameRequest>
}

/// struct for passing parameters to the method [`p_ostv3_teammates`]
#[derive(Clone, Debug, Default)]
pub struct POstv3TeammatesParams {
    pub on_behalf_of: Option<serde_json::Value>,
    pub post_v3_teammates_request: Option<crate::models::PostV3TeammatesRequest>
}

/// struct for passing parameters to the method [`p_ostv3_teammates_pending_token_resend`]
#[derive(Clone, Debug, Default)]
pub struct POstv3TeammatesPendingTokenResendParams {
    /// The token for the invite that you want to resend.
    pub token: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}


/// struct for typed errors of method [`d_eletev3_scopes_requests_request_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEletev3ScopesRequestsRequestIdError {
    Status401(),
    Status404(crate::models::PostV3Teammates400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`d_eletev3_teammates_pending_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEletev3TeammatesPendingTokenError {
    Status404(crate::models::PostV3Teammates400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`d_eletev3_teammates_username`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEletev3TeammatesUsernameError {
    Status404(crate::models::PostV3Teammates400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_etv3_scopes_requests`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtv3ScopesRequestsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_etv3_teammates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtv3TeammatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_etv3_teammates_pending`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtv3TeammatesPendingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_etv3_teammates_username`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtv3TeammatesUsernameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atchv3_scopes_requests_approve_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchv3ScopesRequestsApproveIdError {
    Status401(serde_json::Value),
    Status404(crate::models::PostV3Teammates400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atchv3_teammates_username`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchv3TeammatesUsernameError {
    Status400(crate::models::PostV3Teammates400Response),
    Status404(crate::models::PostV3Teammates400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ostv3_teammates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstv3TeammatesError {
    Status400(crate::models::PostV3Teammates400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ostv3_teammates_pending_token_resend`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstv3TeammatesPendingTokenResendError {
    Status404(crate::models::PostV3Teammates400Response),
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to deny an attempt to access your account.**  **Note:** Only teammate admins may delete a teammate's access request.
pub async fn d_eletev3_scopes_requests_request_id(configuration: &configuration::Configuration, params: DEletev3ScopesRequestsRequestIdParams) -> Result<(), Error<DEletev3ScopesRequestsRequestIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let request_id = params.request_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/scopes/requests/{request_id}", local_var_configuration.base_path, request_id=request_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DEletev3ScopesRequestsRequestIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to delete a pending teammate invite.**
pub async fn d_eletev3_teammates_pending_token(configuration: &configuration::Configuration, params: DEletev3TeammatesPendingTokenParams) -> Result<(), Error<DEletev3TeammatesPendingTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/teammates/pending/{token}", local_var_configuration.base_path, token=token);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DEletev3TeammatesPendingTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to delete a teammate.**  **Only the parent user or an admin teammate can delete another teammate.**
pub async fn d_eletev3_teammates_username(configuration: &configuration::Configuration, params: DEletev3TeammatesUsernameParams) -> Result<crate::models::PostV3Teammates400Response, Error<DEletev3TeammatesUsernameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/teammates/{username}", local_var_configuration.base_path, username=username);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEletev3TeammatesUsernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a list of all recent access requests.**  The Response Header's `link` parameter will include pagination info.
pub async fn g_etv3_scopes_requests(configuration: &configuration::Configuration, params: GEtv3ScopesRequestsParams) -> Result<serde_json::Value, Error<GEtv3ScopesRequestsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/scopes/requests", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtv3ScopesRequestsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a list of all current Teammates.**  You can limit the number of results returned using the `limit` query paramater. To return results from a specific Teammate, use the `offset` paramter. The Response Headers will include pagination info.
pub async fn g_etv3_teammates(configuration: &configuration::Configuration, params: GEtv3TeammatesParams) -> Result<crate::models::GetV3Teammates200Response, Error<GEtv3TeammatesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let limit = params.limit;
    let offset = params.offset;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/teammates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtv3TeammatesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a list of all pending Teammate invitations.**  Each teammate invitation is valid for 7 days. Users may resend the invitation to refresh the expiration date.
pub async fn g_etv3_teammates_pending(configuration: &configuration::Configuration, params: GEtv3TeammatesPendingParams) -> Result<crate::models::GetV3TeammatesPending200Response, Error<GEtv3TeammatesPendingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/teammates/pending", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtv3TeammatesPendingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a specific Teammate by username.**  You can retrieve the username's for each of your Teammates using the \"Retrieve all Teammates\" endpoint.
pub async fn g_etv3_teammates_username(configuration: &configuration::Configuration, params: GEtv3TeammatesUsernameParams) -> Result<crate::models::GetV3TeammatesUsername200Response, Error<GEtv3TeammatesUsernameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/teammates/{username}", local_var_configuration.base_path, username=username);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtv3TeammatesUsernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to approve an access attempt.**  **Note:** Only teammate admins may approve another teammate’s access request.
pub async fn p_atchv3_scopes_requests_approve_id(configuration: &configuration::Configuration, params: PAtchv3ScopesRequestsApproveIdParams) -> Result<crate::models::PatchV3ScopesRequestsApproveId200Response, Error<PAtchv3ScopesRequestsApproveIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let request_id = params.request_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/scopes/requests/{request_id}/approve", local_var_configuration.base_path, request_id=request_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchv3ScopesRequestsApproveIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to update a teammate’s permissions.**  To turn a teammate into an admin, the request body should contain an `is_admin` set to `true`. Otherwise, set `is_admin` to `false` and pass in all the scopes that a teammate should have.  **Only the parent user or other admin teammates can update another teammate’s permissions.**  **Admin users can only update permissions.**
pub async fn p_atchv3_teammates_username(configuration: &configuration::Configuration, params: PAtchv3TeammatesUsernameParams) -> Result<crate::models::PatchV3TeammatesUsername200Response, Error<PAtchv3TeammatesUsernameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;
    let on_behalf_of = params.on_behalf_of;
    let patch_v3_teammates_username_request = params.patch_v3_teammates_username_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/teammates/{username}", local_var_configuration.base_path, username=username);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&patch_v3_teammates_username_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchv3TeammatesUsernameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to invite a Teammate to your account via email.**  You can set a Teammate's initial permissions using the `scopes` array in the request body. Teammate's will receive a minimum set of scopes from Twilio SendGrid that are necessary for the Teammate to function.  **Note:** A teammate invite will expire after 7 days, but you may resend the invitation at any time to reset the expiration date.
pub async fn p_ostv3_teammates(configuration: &configuration::Configuration, params: POstv3TeammatesParams) -> Result<crate::models::PostV3Teammates201Response, Error<POstv3TeammatesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;
    let post_v3_teammates_request = params.post_v3_teammates_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/teammates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_v3_teammates_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstv3TeammatesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to resend a Teammate invitation.**  Teammate invitations will expire after 7 days. Resending an invitation will reset the expiration date.
pub async fn p_ostv3_teammates_pending_token_resend(configuration: &configuration::Configuration, params: POstv3TeammatesPendingTokenResendParams) -> Result<crate::models::PostV3TeammatesPendingTokenResend200Response, Error<POstv3TeammatesPendingTokenResendError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let token = params.token;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/teammates/pending/{token}/resend", local_var_configuration.base_path, token=token);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstv3TeammatesPendingTokenResendError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

