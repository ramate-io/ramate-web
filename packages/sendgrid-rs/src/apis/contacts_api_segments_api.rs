/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_contactdb_segments_segment_id`]
#[derive(Clone, Debug, Default)]
pub struct DEleteContactdbSegmentsSegmentIdParams {
    pub segment_id: serde_json::Value,
    /// True to delete all contacts matching the segment in addition to deleting the segment
    pub delete_contacts: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>,
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_contactdb_segments`]
#[derive(Clone, Debug, Default)]
pub struct GEtContactdbSegmentsParams {
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_contactdb_segments_segment_id`]
#[derive(Clone, Debug, Default)]
pub struct GEtContactdbSegmentsSegmentIdParams {
    /// The ID of the segment you want to request.
    pub segment_id: serde_json::Value,
    pub segment_id2: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_contactdb_segments_segment_id_recipients`]
#[derive(Clone, Debug, Default)]
pub struct GEtContactdbSegmentsSegmentIdRecipientsParams {
    /// The ID of the segment from which you want to retrieve recipients.
    pub segment_id: serde_json::Value,
    pub page: Option<serde_json::Value>,
    pub page_size: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`p_atch_contactdb_segments_segment_id`]
#[derive(Clone, Debug, Default)]
pub struct PAtchContactdbSegmentsSegmentIdParams {
    pub segment_id2: serde_json::Value,
    /// The ID of the segment you are updating.
    pub segment_id: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>,
    pub patch_contactdb_segments_segment_id_request: Option<crate::models::PatchContactdbSegmentsSegmentIdRequest>
}

/// struct for passing parameters to the method [`p_ost_contactdb_segments`]
#[derive(Clone, Debug, Default)]
pub struct POstContactdbSegmentsParams {
    pub on_behalf_of: Option<serde_json::Value>,
    pub contactdb_segments: Option<crate::models::ContactdbSegments>
}


/// struct for typed errors of method [`d_elete_contactdb_segments_segment_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteContactdbSegmentsSegmentIdError {
    Status400(crate::models::GlobalErrorResponseSchema),
    Status401(crate::models::GlobalErrorResponseSchema),
    Status404(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_contactdb_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtContactdbSegmentsError {
    Status401(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_contactdb_segments_segment_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtContactdbSegmentsSegmentIdError {
    Status400(crate::models::GlobalErrorResponseSchema),
    Status401(crate::models::GlobalErrorResponseSchema),
    Status404(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_contactdb_segments_segment_id_recipients`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtContactdbSegmentsSegmentIdRecipientsError {
    Status400(serde_json::Value),
    Status401(crate::models::GlobalErrorResponseSchema),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_contactdb_segments_segment_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchContactdbSegmentsSegmentIdError {
    Status400(crate::models::GlobalErrorResponseSchema),
    Status401(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_contactdb_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstContactdbSegmentsError {
    Status400(crate::models::GlobalErrorResponseSchema),
    Status401(crate::models::GlobalErrorResponseSchema),
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to delete a segment from your recipients database.**  You also have the option to delete all the contacts from your Marketing Campaigns recipient database who were in this segment.
pub async fn d_elete_contactdb_segments_segment_id(configuration: &configuration::Configuration, params: DEleteContactdbSegmentsSegmentIdParams) -> Result<serde_json::Value, Error<DEleteContactdbSegmentsSegmentIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;
    let delete_contacts = params.delete_contacts;
    let on_behalf_of = params.on_behalf_of;
    let body = params.body;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/contactdb/segments/{segment_id}", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delete_contacts {
        local_var_req_builder = local_var_req_builder.query(&[("delete_contacts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteContactdbSegmentsSegmentIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve all of your segments.**
pub async fn g_et_contactdb_segments(configuration: &configuration::Configuration, params: GEtContactdbSegmentsParams) -> Result<crate::models::ListAllSegmentsResponse, Error<GEtContactdbSegmentsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/contactdb/segments", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtContactdbSegmentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a single segment with the given ID.**
pub async fn g_et_contactdb_segments_segment_id(configuration: &configuration::Configuration, params: GEtContactdbSegmentsSegmentIdParams) -> Result<crate::models::ContactdbSegments, Error<GEtContactdbSegmentsSegmentIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;
    let segment_id2 = params.segment_id2;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/contactdb/segments/{segment_id}", local_var_configuration.base_path, segment_id=segment_id2);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("segment_id", &segment_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtContactdbSegmentsSegmentIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve all of the recipients in a segment with the given ID.**
pub async fn g_et_contactdb_segments_segment_id_recipients(configuration: &configuration::Configuration, params: GEtContactdbSegmentsSegmentIdRecipientsParams) -> Result<crate::models::ListRecipientsOnASegmentResponse, Error<GEtContactdbSegmentsSegmentIdRecipientsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id = params.segment_id;
    let page = params.page;
    let page_size = params.page_size;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/contactdb/segments/{segment_id}/recipients", local_var_configuration.base_path, segment_id=segment_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtContactdbSegmentsSegmentIdRecipientsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to update a segment.**
pub async fn p_atch_contactdb_segments_segment_id(configuration: &configuration::Configuration, params: PAtchContactdbSegmentsSegmentIdParams) -> Result<crate::models::ContactdbSegments, Error<PAtchContactdbSegmentsSegmentIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let segment_id2 = params.segment_id2;
    let segment_id = params.segment_id;
    let on_behalf_of = params.on_behalf_of;
    let patch_contactdb_segments_segment_id_request = params.patch_contactdb_segments_segment_id_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/contactdb/segments/{segment_id}", local_var_configuration.base_path, segment_id=segment_id2);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = segment_id {
        local_var_req_builder = local_var_req_builder.query(&[("segment_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&patch_contactdb_segments_segment_id_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchContactdbSegmentsSegmentIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to create a new segment.**     Valid operators for create and update depend on the type of the field for which you are searching.  **Dates** - \"eq\", \"ne\", \"lt\" (before), \"gt\" (after)     - You may use MM/DD/YYYY for day granularity or an epoch for second granularity. - \"empty\", \"not_empty\" - \"is within\"     - You may use an [ISO 8601 date format](https://en.wikipedia.org/wiki/ISO_8601) or the # of days.  **Text** - \"contains\" - \"eq\" (is/equals - matches the full field) - \"ne\" (is not/not equals - matches any field where the entire field is not the condition value) - \"empty\" - \"not_empty\"  **Numbers** - \"eq\" (is/equals) - \"lt\" (is less than) - \"gt\" (is greater than) - \"empty\" - \"not_empty\"  **Email Clicks and Opens** - \"eq\" (opened) - \"ne\" (not opened)  All field values must be a string.   Conditions using \"eq\" or \"ne\" for email clicks and opens should provide a \"field\" of either `clicks.campaign_identifier` or `opens.campaign_identifier`. The condition value should be a string containing the id of a completed campaign.   The conditions list may contain multiple conditions, joined by an \"and\" or \"or\" in the \"and_or\" field.  The first condition in the conditions list must have an empty \"and_or\", and subsequent conditions must all specify an \"and_or\".
pub async fn p_ost_contactdb_segments(configuration: &configuration::Configuration, params: POstContactdbSegmentsParams) -> Result<serde_json::Value, Error<POstContactdbSegmentsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;
    let contactdb_segments = params.contactdb_segments;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/contactdb/segments", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&contactdb_segments);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstContactdbSegmentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

