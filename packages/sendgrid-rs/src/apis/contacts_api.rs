/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_eletemc_contacts`]
#[derive(Clone, Debug, Default)]
pub struct DEletemcContactsParams {
    /// Must be set to `\"true\"` to delete all contacts.
    pub delete_all_contacts: Option<serde_json::Value>,
    /// A comma-separated list of contact IDs.
    pub ids: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_marketing_contacts_imports_id`]
#[derive(Clone, Debug, Default)]
pub struct GEtMarketingContactsImportsIdParams {
    pub id: serde_json::Value
}

/// struct for passing parameters to the method [`g_etmc_contacts_exports_id`]
#[derive(Clone, Debug, Default)]
pub struct GEtmcContactsExportsIdParams {
    pub id: serde_json::Value
}

/// struct for passing parameters to the method [`g_etmc_contacts_id`]
#[derive(Clone, Debug, Default)]
pub struct GEtmcContactsIdParams {
    pub id: serde_json::Value
}

/// struct for passing parameters to the method [`p_ost_marketing_contacts_batch`]
#[derive(Clone, Debug, Default)]
pub struct POstMarketingContactsBatchParams {
    pub post_marketing_contacts_batch_request: Option<crate::models::PostMarketingContactsBatchRequest>
}

/// struct for passing parameters to the method [`p_ost_marketing_contacts_search_emails`]
#[derive(Clone, Debug, Default)]
pub struct POstMarketingContactsSearchEmailsParams {
    pub post_marketing_contacts_search_emails_request: Option<crate::models::PostMarketingContactsSearchEmailsRequest>
}

/// struct for passing parameters to the method [`p_ostmc_contacts_exports`]
#[derive(Clone, Debug, Default)]
pub struct POstmcContactsExportsParams {
    pub post_mc_contacts_exports_request: Option<crate::models::PostMcContactsExportsRequest>
}

/// struct for passing parameters to the method [`p_ostmc_contacts_search`]
#[derive(Clone, Debug, Default)]
pub struct POstmcContactsSearchParams {
    pub post_mc_contacts_search_request: Option<crate::models::PostMcContactsSearchRequest>
}

/// struct for passing parameters to the method [`p_utmc_contacts`]
#[derive(Clone, Debug, Default)]
pub struct PUtmcContactsParams {
    pub put_mc_contacts_request: Option<crate::models::PutMcContactsRequest>
}

/// struct for passing parameters to the method [`p_utmc_contacts_imports`]
#[derive(Clone, Debug, Default)]
pub struct PUtmcContactsImportsParams {
    pub put_mc_contacts_imports_request: Option<crate::models::PutMcContactsImportsRequest>
}


/// struct for typed errors of method [`d_eletemc_contacts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEletemcContactsError {
    Status400(crate::models::DeleteMcContacts400Response),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_marketing_contacts_exports`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtMarketingContactsExportsError {
    Status400(crate::models::GetMarketingContactsExports400Response),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_marketing_contacts_imports_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtMarketingContactsImportsIdError {
    Status400(crate::models::GetMarketingContactsImportsId400Response),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_etmc_contacts_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtmcContactsCountError {
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_etmc_contacts_exports_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtmcContactsExportsIdError {
    Status400(crate::models::GetMcContats400Response),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_etmc_contacts_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtmcContactsIdError {
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_etmc_contats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtmcContatsError {
    Status400(crate::models::GetMcContats400Response),
    Status401(),
    Status403(),
    Status404(serde_json::Value),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_marketing_contacts_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstMarketingContactsBatchError {
    Status401(),
    Status403(),
    Status404(serde_json::Value),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_marketing_contacts_search_emails`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstMarketingContactsSearchEmailsError {
    Status400(crate::models::GlobalErrorResponseSchema),
    Status401(),
    Status403(),
    Status404(crate::models::GlobalErrorResponseSchema),
    Status500(crate::models::PostMcContactsSearch500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ostmc_contacts_exports`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstmcContactsExportsError {
    Status400(crate::models::GetMcContats400Response),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ostmc_contacts_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstmcContactsSearchError {
    Status400(crate::models::PostV3Teammates400Response),
    Status401(),
    Status403(),
    Status404(),
    Status408(),
    Status500(crate::models::PostMcContactsSearch500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_utmc_contacts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PUtmcContactsError {
    Status400(crate::models::GetMcContats400Response),
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_utmc_contacts_imports`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PUtmcContactsImportsError {
    Status400(crate::models::PutMcContactsImports400Response),
    Status401(),
    Status403(),
    Status404(crate::models::PutMcContactsImports404Response),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// **This endpoint can be used to delete one or more contacts**.  The query parameter `ids` must set to a comma-separated list of contact IDs for bulk contact deletion.  The query parameter `delete_all_contacts` must be set to `\"true\"` to delete **all** contacts.   You must set either `ids` or `delete_all_contacts`.  Deletion jobs are processed asynchronously.  Twilio SendGrid recommends exporting your contacts regularly as a backup to avoid issues or lost data.
pub async fn d_eletemc_contacts(configuration: &configuration::Configuration, params: DEletemcContactsParams) -> Result<crate::models::DeleteMcContacts202Response, Error<DEletemcContactsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let delete_all_contacts = params.delete_all_contacts;
    let ids = params.ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delete_all_contacts {
        local_var_req_builder = local_var_req_builder.query(&[("delete_all_contacts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ids {
        local_var_req_builder = local_var_req_builder.query(&[("ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEletemcContactsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **Use this endpoint to retrieve details of all current exported jobs**.  It will return an array of objects, each of which records an export job in flight or recently completed.   Each object's `export_type` field will tell you which kind of export it is and its `status` field will indicate what stage of processing it has reached. Exports which are `ready` will be accompanied by a `urls` field which lists the URLs of the export's downloadable files â€” there will be more than one if you specified a maximum file size in your initial export request.  Use this endpoint if you have exports in flight but do not know their IDs, which are required for the \"Export Contacts Status\" endpoint.
pub async fn g_et_marketing_contacts_exports(configuration: &configuration::Configuration) -> Result<crate::models::GetMarketingContactsExports200Response, Error<GEtMarketingContactsExportsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/exports", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtMarketingContactsExportsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint can be used to check the status of a contact import job**.   Use the `job_id` from the \"Import Contacts,\" \"Add or Update a Contact,\" or \"Delete Contacts\" endpoints as the `id` in the path parameter.  If there is an error with your `PUT` request, download the `errors_url` file and open it to view more details.  The job `status` field indicates whether the job is `pending`, `completed`, `errored`, or `failed`.   Pending means not started. Completed means finished without any errors. Errored means finished with some errors. Failed means finshed with all errors, or the job was entirely unprocessable: for example, if you attempt to import file format we do not support.  The `results` object will have fields depending on the job type.  Twilio SendGrid recommends exporting your contacts regularly as a backup to avoid issues or lost data.
pub async fn g_et_marketing_contacts_imports_id(configuration: &configuration::Configuration, params: GEtMarketingContactsImportsIdParams) -> Result<crate::models::ContactImport, Error<GEtMarketingContactsImportsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/imports/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtMarketingContactsImportsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint returns the total number of contacts you have stored.**   Twilio SendGrid recommends exporting your contacts regularly as a backup to avoid issues or lost data.
pub async fn g_etmc_contacts_count(configuration: &configuration::Configuration) -> Result<crate::models::GetMcContactsCount200Response, Error<GEtmcContactsCountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/count", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtmcContactsCountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint can be used to check the status of a contact export job**.   To use this call, you will need the `id` from the \"Export Contacts\" call.  If you would like to download a list, take the `id` that is returned from the \"Export Contacts\" endpoint and make an API request here to get the `urls`. Once you have the list of URLs, make a `GET` request on each URL to download your CSV file(s).  Twilio SendGrid recommends exporting your contacts regularly as a backup to avoid issues or lost data.
pub async fn g_etmc_contacts_exports_id(configuration: &configuration::Configuration, params: GEtmcContactsExportsIdParams) -> Result<crate::models::ContactExport, Error<GEtmcContactsExportsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/exports/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtmcContactsExportsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint returns the full details and all fields for the specified contact**.  The \"Get Contacts by Emails\" endpoint can be used to get the ID of a contact.
pub async fn g_etmc_contacts_id(configuration: &configuration::Configuration, params: GEtmcContactsIdParams) -> Result<crate::models::ContactDetails3, Error<GEtmcContactsIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/{id}", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtmcContactsIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint will return up to 50 of the most recent contacts uploaded or attached to a list**.   This list will then be sorted by email address.  The full contact count is also returned.  Please note that pagination of the contacts has been deprecated.  Twilio SendGrid recommends exporting your contacts regularly as a backup to avoid issues or lost data.
pub async fn g_etmc_contats(configuration: &configuration::Configuration) -> Result<crate::models::GetMcContats200Response, Error<GEtmcContatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtmcContatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint is used to retrieve a set of contacts identified by their IDs.**  This can be more efficient endpoint to get contacts than making a series of individual `GET` requests to the \"Get a Contact by ID\" endpoint.  You can supply up to 100 IDs. Pass them into the `ids` field in your request body as an array or one or more strings.  Twilio SendGrid recommends exporting your contacts regularly as a backup to avoid issues or lost data.
pub async fn p_ost_marketing_contacts_batch(configuration: &configuration::Configuration, params: POstMarketingContactsBatchParams) -> Result<crate::models::PostMarketingContactsBatch200Response, Error<POstMarketingContactsBatchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_marketing_contacts_batch_request = params.post_marketing_contacts_batch_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/batch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&post_marketing_contacts_batch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstMarketingContactsBatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve up to 100 contacts matching the searched `email` address(es), including any `alternate_emails`.**   Email addresses are unique to a contact, meaning this endpoint can treat an email address as a primary key to search by. The contact object associated with the address, whether it is their `email` or one of their `alternate_emails` will be returned if matched.  Email addresses in the search request do not need to match the case in which they're stored, but the email addresses in the result will be all lower case. Empty strings are excluded from the search and will not be returned.  This endpoint should be used in place of the \"Search Contacts\" endpoint when you can provide exact email addresses and do not need to include other [Segmentation Query Language (SGQL)](https://sendgrid.com/docs/for-developers/sending-email/segmentation-query-language/) filters when searching.  If you need to access a large percentage of your contacts, we recommend exporting your contacts with the \"Export Contacts\" endpoint and filtering the results client side.  This endpoint returns a `200` status code when any contacts match the address(es) you supplied. When searching multiple addresses in a single request, it is possible that some addresses will match a contact while others will not. When a partially successful search like this is made, the matching contacts are returned in an object and an error message is returned for the email address(es) that are not found.   This endpoint returns a `404` status code when no contacts are found for the provided email address(es).  A `400` status code is returned if any searched addresses are invalid.  Twilio SendGrid recommends exporting your contacts regularly as a backup to avoid issues or lost data.
pub async fn p_ost_marketing_contacts_search_emails(configuration: &configuration::Configuration, params: POstMarketingContactsSearchEmailsParams) -> Result<crate::models::PostMarketingContactsSearchEmails200Response, Error<POstMarketingContactsSearchEmailsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_marketing_contacts_search_emails_request = params.post_marketing_contacts_search_emails_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/search/emails", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_marketing_contacts_search_emails_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstMarketingContactsSearchEmailsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **Use this endpoint to export lists or segments of contacts**.  If you would just like to have a link to the exported list sent to your email set the `notifications.email` option to `true` in the `POST` payload.  If you would like to download the list, take the `id` that is returned and use the \"Export Contacts Status\" endpoint to get the `urls`. Once you have the list of URLs, make a `GET` request to each URL provided to download your CSV file(s).  You specify the segements and or/contact lists you wish to export by providing the relevant IDs in, respectively, the `segment_ids` and `list_ids` fields in the request body.  The lists will be provided in either JSON or CSV files. To specify which of these you would required, set the request body `file_type` field to `json` or `csv`.  You can also specify a maximum file size (in MB). If the export file is larger than this, it will be split into multiple files.
pub async fn p_ostmc_contacts_exports(configuration: &configuration::Configuration, params: POstmcContactsExportsParams) -> Result<crate::models::PostMcContactsExports202Response, Error<POstmcContactsExportsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_mc_contacts_exports_request = params.post_mc_contacts_exports_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/exports", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_mc_contacts_exports_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstmcContactsExportsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **Use this endpoint to locate contacts**.  The request body's `query` field accepts valid [SGQL](https://sendgrid.com/docs/for-developers/sending-email/segmentation-query-language/) for searching for a contact.  Because contact emails are stored in lower case, using SGQL to search by email address requires the provided email address to be in lower case. The SGQL `lower()` function can be used for this.  Only the first 50 contacts that meet the search criteria will be returned.  If the query takes longer than 20 seconds, a `408 Request Timeout` status will be returned.  Formatting the `created_at` and `updated_at` values as Unix timestamps is deprecated. Instead they are returned as ISO format as string.
pub async fn p_ostmc_contacts_search(configuration: &configuration::Configuration, params: POstmcContactsSearchParams) -> Result<crate::models::PostMcContactsSearch200Response, Error<POstmcContactsSearchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_mc_contacts_search_request = params.post_mc_contacts_search_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_mc_contacts_search_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstmcContactsSearchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows the [upsert](https://en.wiktionary.org/wiki/upsert) (insert or update) of up to 30,000 contacts, or 6MB of data, whichever is lower**.   Because the creation and update of contacts is an asynchronous process, the response will not contain immediate feedback on the processing of your upserted contacts. Rather, it will contain an HTTP 202 response indicating the contacts are queued for processing or an HTTP 4XX error containing validation errors. Should you wish to get the resulting contact's ID or confirm your contacts have been updated or added, you can use the \"Get Contacts by Emails\" endpoint.   Please note that custom fields need to have been already created if you wish to set their values for the contacts being upserted. To do this, please use the \"Create Custom Field Definition\" endpoint.  You will see a `job_id` in the response to your request. This can be used to check the status of your upsert job. To do so, please use the \"Import Contacts Status\" endpoint.  If the contact already exists in the system, any entries submitted via this endpoint will update the existing contact. The contact to update will be determined only by the `email` field and any fields omitted from the request will remain as they were. A contact's ID cannot be used to update the contact.  The email field will be changed to all lower-case. If a contact is added with an email that exists but contains capital letters, the existing contact with the all lower-case email will be updated.
pub async fn p_utmc_contacts(configuration: &configuration::Configuration, params: PUtmcContactsParams) -> Result<crate::models::PutMcContacts202Response, Error<PUtmcContactsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let put_mc_contacts_request = params.put_mc_contacts_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&put_mc_contacts_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PUtmcContactsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows a CSV upload containing up to one million contacts or 5GB of data, whichever is smaller.**  Imports take place asynchronously: the endpoint returns a URL (`upload_uri`) and HTTP headers (`upload_headers`) which can subsequently be used to `PUT` a file of contacts to be  imported into our system.  Uploaded CSV files may also be [gzip-compressed](https://en.wikipedia.org/wiki/Gzip).  In either case, you must include the field `file_type` with the value `csv` in your request body.  The `field_mappings` paramter is a respective list of field definition IDs to map the uploaded CSV columns to. It allows you to use CSVs where one or more columns are skipped (`null`) or remapped to the contact field.   For example, if `field_mappings` is set to `[null, \"w1\", \"_rf1\"]`, this means skip column 0, map column 1 to the custom field with the ID `w1`, and map column 2 to the reserved field with the ID `_rf1`. See the \"Get All Field Definitions\" endpoint to fetch your custom and reserved field IDs to use with `field_mappings`.  Once you recieve the response body you can then initiate a **second** API call where you use the supplied URL and HTTP header to upload your file. For example:  `curl --upload-file \"file/path.csv\" \"URL_GIVEN\" -H 'HEADER_GIVEN'`  If you'd like to monitor the status of your import job, use the `job_id` and the \"Import Contacts Status\" endpoint.  Twilio SendGrid recommends exporting your contacts regularly as a backup to avoid issues or lost data.
pub async fn p_utmc_contacts_imports(configuration: &configuration::Configuration, params: PUtmcContactsImportsParams) -> Result<crate::models::PutMcContactsImports200Response, Error<PUtmcContactsImportsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let put_mc_contacts_imports_request = params.put_mc_contacts_imports_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/marketing/contacts/imports", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&put_mc_contacts_imports_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PUtmcContactsImportsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

