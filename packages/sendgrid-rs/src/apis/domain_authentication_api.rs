/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`d_elete_whitelabel_domains_domain_id`]
#[derive(Clone, Debug, Default)]
pub struct DEleteWhitelabelDomainsDomainIdParams {
    pub domain_id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`d_elete_whitelabel_domains_id_ips_ip`]
#[derive(Clone, Debug, Default)]
pub struct DEleteWhitelabelDomainsIdIpsIpParams {
    /// ID of the domain to delete the IP from.
    pub id: serde_json::Value,
    /// IP to remove from the domain.
    pub ip: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`d_elete_whitelabel_domains_subuser`]
#[derive(Clone, Debug, Default)]
pub struct DEleteWhitelabelDomainsSubuserParams {
    /// Username for the subuser to find associated authenticated domain.
    pub username: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_whitelabel_domains`]
#[derive(Clone, Debug, Default)]
pub struct GEtWhitelabelDomainsParams {
    /// Number of domains to return.
    pub limit: Option<serde_json::Value>,
    /// Paging offset.
    pub offset: Option<serde_json::Value>,
    /// Exclude subuser domains from the result.
    pub exclude_subusers: Option<serde_json::Value>,
    /// The username associated with an authenticated domain.
    pub username: Option<serde_json::Value>,
    /// Search for authenticated domains.
    pub domain: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_whitelabel_domains_default`]
#[derive(Clone, Debug, Default)]
pub struct GEtWhitelabelDomainsDefaultParams {
    /// The domain to find a default authentication.
    pub domain: Option<serde_json::Value>,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_whitelabel_domains_domain_id`]
#[derive(Clone, Debug, Default)]
pub struct GEtWhitelabelDomainsDomainIdParams {
    pub domain_id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`g_et_whitelabel_domains_subuser`]
#[derive(Clone, Debug, Default)]
pub struct GEtWhitelabelDomainsSubuserParams {
    /// Username for the subuser to find associated authenticated domain.
    pub username: serde_json::Value
}

/// struct for passing parameters to the method [`p_atch_whitelabel_domains_domain_id`]
#[derive(Clone, Debug, Default)]
pub struct PAtchWhitelabelDomainsDomainIdParams {
    pub domain_id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>,
    pub patch_whitelabel_domains_domain_id_request: Option<crate::models::PatchWhitelabelDomainsDomainIdRequest>
}

/// struct for passing parameters to the method [`p_ost_whitelabel_domains`]
#[derive(Clone, Debug, Default)]
pub struct POstWhitelabelDomainsParams {
    pub on_behalf_of: Option<serde_json::Value>,
    pub post_whitelabel_domains_request: Option<crate::models::PostWhitelabelDomainsRequest>
}

/// struct for passing parameters to the method [`p_ost_whitelabel_domains_domain_id_subuser`]
#[derive(Clone, Debug, Default)]
pub struct POstWhitelabelDomainsDomainIdSubuserParams {
    /// ID of the authenticated domain to associate with the subuser
    pub domain_id: serde_json::Value,
    pub post_whitelabel_domains_domain_id_subuser_request: Option<crate::models::PostWhitelabelDomainsDomainIdSubuserRequest>
}

/// struct for passing parameters to the method [`p_ost_whitelabel_domains_id_ips`]
#[derive(Clone, Debug, Default)]
pub struct POstWhitelabelDomainsIdIpsParams {
    /// ID of the domain to which you are adding an IP
    pub id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>,
    pub post_whitelabel_domains_id_ips_request: Option<crate::models::PostWhitelabelDomainsIdIpsRequest>
}

/// struct for passing parameters to the method [`p_ost_whitelabel_domains_id_validate`]
#[derive(Clone, Debug, Default)]
pub struct POstWhitelabelDomainsIdValidateParams {
    /// ID of the domain to validate.
    pub id: serde_json::Value,
    pub on_behalf_of: Option<serde_json::Value>
}


/// struct for typed errors of method [`d_elete_whitelabel_domains_domain_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteWhitelabelDomainsDomainIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`d_elete_whitelabel_domains_id_ips_ip`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteWhitelabelDomainsIdIpsIpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`d_elete_whitelabel_domains_subuser`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DEleteWhitelabelDomainsSubuserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_whitelabel_domains`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtWhitelabelDomainsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_whitelabel_domains_default`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtWhitelabelDomainsDefaultError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_whitelabel_domains_domain_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtWhitelabelDomainsDomainIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`g_et_whitelabel_domains_subuser`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GEtWhitelabelDomainsSubuserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_atch_whitelabel_domains_domain_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PAtchWhitelabelDomainsDomainIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_whitelabel_domains`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstWhitelabelDomainsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_whitelabel_domains_domain_id_subuser`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstWhitelabelDomainsDomainIdSubuserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_whitelabel_domains_id_ips`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstWhitelabelDomainsIdIpsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`p_ost_whitelabel_domains_id_validate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstWhitelabelDomainsIdValidateError {
    Status500(crate::models::PostWhitelabelDomainsIdValidate500Response),
    UnknownValue(serde_json::Value),
}


/// **This endpoint allows you to delete an authenticated domain.**
pub async fn d_elete_whitelabel_domains_domain_id(configuration: &configuration::Configuration, params: DEleteWhitelabelDomainsDomainIdParams) -> Result<serde_json::Value, Error<DEleteWhitelabelDomainsDomainIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let domain_id = params.domain_id;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/{domain_id}", local_var_configuration.base_path, domain_id=domain_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteWhitelabelDomainsDomainIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to remove an IP address from that domain's authentication.**
pub async fn d_elete_whitelabel_domains_id_ips_ip(configuration: &configuration::Configuration, params: DEleteWhitelabelDomainsIdIpsIpParams) -> Result<crate::models::DomainAuthenticationDomainSpf, Error<DEleteWhitelabelDomainsIdIpsIpError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let ip = params.ip;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/{id}/ips/{ip}", local_var_configuration.base_path, id=id, ip=ip);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteWhitelabelDomainsIdIpsIpError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to disassociate a specific authenticated domain from a subuser.**  Authenticated domains can be associated with (i.e. assigned to) subusers from a parent account. This functionality allows subusers to send mail using their parent's domain authentication. To associate an authenticated domain with a subuser, the parent account must first authenticate and validate the domain. The parent may then associate the authenticated domain via the subuser management tools.
pub async fn d_elete_whitelabel_domains_subuser(configuration: &configuration::Configuration, params: DEleteWhitelabelDomainsSubuserParams) -> Result<serde_json::Value, Error<DEleteWhitelabelDomainsSubuserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/subuser", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = username {
        local_var_req_builder = local_var_req_builder.query(&[("username", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DEleteWhitelabelDomainsSubuserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a list of all domains you have authenticated.**
pub async fn g_et_whitelabel_domains(configuration: &configuration::Configuration, params: GEtWhitelabelDomainsParams) -> Result<serde_json::Value, Error<GEtWhitelabelDomainsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let limit = params.limit;
    let offset = params.offset;
    let exclude_subusers = params.exclude_subusers;
    let username = params.username;
    let domain = params.domain;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_subusers {
        local_var_req_builder = local_var_req_builder.query(&[("exclude_subusers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = username {
        local_var_req_builder = local_var_req_builder.query(&[("username", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = domain {
        local_var_req_builder = local_var_req_builder.query(&[("domain", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtWhitelabelDomainsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve the default authentication for a domain.**  When creating or updating a domain authentication, you can set the domain as a default. The default domain will be used to send all mail. If you have multiple authenticated domains, the authenticated domain matching the domain of the From address will be used, and the default will be overridden.  This endpoint will return a default domain and its details only if a default is set. You are not required to set a default. If you do not set a default domain, this endpoint will return general information about your domain authentication status.
pub async fn g_et_whitelabel_domains_default(configuration: &configuration::Configuration, params: GEtWhitelabelDomainsDefaultParams) -> Result<serde_json::Value, Error<GEtWhitelabelDomainsDefaultError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let domain = params.domain;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/default", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = domain {
        local_var_req_builder = local_var_req_builder.query(&[("domain", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtWhitelabelDomainsDefaultError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve a specific authenticated domain.**
pub async fn g_et_whitelabel_domains_domain_id(configuration: &configuration::Configuration, params: GEtWhitelabelDomainsDomainIdParams) -> Result<crate::models::AuthenticationDomain, Error<GEtWhitelabelDomainsDomainIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let domain_id = params.domain_id;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/{domain_id}", local_var_configuration.base_path, domain_id=domain_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtWhitelabelDomainsDomainIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to retrieve all of the authenticated domains that have been assigned to a specific subuser.**  Authenticated domains can be associated with (i.e. assigned to) subusers from a parent account. This functionality allows subusers to send mail using their parent's domain authentication. To associate an authenticated domain with a subuser, the parent account must first authenticate and validate the domain. The parent may then associate the authenticated domain via the subuser management tools.
pub async fn g_et_whitelabel_domains_subuser(configuration: &configuration::Configuration, params: GEtWhitelabelDomainsSubuserParams) -> Result<crate::models::DomainAuthenticationDomainSpf, Error<GEtWhitelabelDomainsSubuserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/subuser", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("username", &username.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GEtWhitelabelDomainsSubuserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to update the settings for an authenticated domain.**
pub async fn p_atch_whitelabel_domains_domain_id(configuration: &configuration::Configuration, params: PAtchWhitelabelDomainsDomainIdParams) -> Result<serde_json::Value, Error<PAtchWhitelabelDomainsDomainIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let domain_id = params.domain_id;
    let on_behalf_of = params.on_behalf_of;
    let patch_whitelabel_domains_domain_id_request = params.patch_whitelabel_domains_domain_id_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/{domain_id}", local_var_configuration.base_path, domain_id=domain_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&patch_whitelabel_domains_domain_id_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PAtchWhitelabelDomainsDomainIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to authenticate a domain.**  If you are authenticating a domain for a subuser, you have two options: 1. Use the \"username\" parameter. This allows you to authenticate a domain on behalf of your subuser. This means the subuser is able to see and modify the authenticated domain. 2. Use the Association workflow (see Associate Domain section). This allows you to authenticate a domain created by the parent to a subuser. This means the subuser will default to the assigned domain, but will not be able to see or modify that authenticated domain. However, if the subuser authenticates their own domain it will overwrite the assigned domain.
pub async fn p_ost_whitelabel_domains(configuration: &configuration::Configuration, params: POstWhitelabelDomainsParams) -> Result<crate::models::AuthenticationDomain, Error<POstWhitelabelDomainsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let on_behalf_of = params.on_behalf_of;
    let post_whitelabel_domains_request = params.post_whitelabel_domains_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_whitelabel_domains_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstWhitelabelDomainsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to associate a specific authenticated domain with a subuser.**  Authenticated domains can be associated with (i.e. assigned to) subusers from a parent account. This functionality allows subusers to send mail using their parent's domain authentication. To associate an authenticated domain with a subuser, the parent account must first authenticate and validate the domain. The parent may then associate the authenticated domain via the subuser management tools.
pub async fn p_ost_whitelabel_domains_domain_id_subuser(configuration: &configuration::Configuration, params: POstWhitelabelDomainsDomainIdSubuserParams) -> Result<crate::models::DomainAuthenticationDomainSpf, Error<POstWhitelabelDomainsDomainIdSubuserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let domain_id = params.domain_id;
    let post_whitelabel_domains_domain_id_subuser_request = params.post_whitelabel_domains_domain_id_subuser_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/{domain_id}/subuser", local_var_configuration.base_path, domain_id=domain_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_whitelabel_domains_domain_id_subuser_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstWhitelabelDomainsDomainIdSubuserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to add an IP address to an authenticated domain.**
pub async fn p_ost_whitelabel_domains_id_ips(configuration: &configuration::Configuration, params: POstWhitelabelDomainsIdIpsParams) -> Result<crate::models::DomainAuthenticationDomainSpf, Error<POstWhitelabelDomainsIdIpsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let on_behalf_of = params.on_behalf_of;
    let post_whitelabel_domains_id_ips_request = params.post_whitelabel_domains_id_ips_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/{id}/ips", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_whitelabel_domains_id_ips_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstWhitelabelDomainsIdIpsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint allows you to validate an authenticated domain. If it fails, it will return an error message describing why the domain could not be validated.**
pub async fn p_ost_whitelabel_domains_id_validate(configuration: &configuration::Configuration, params: POstWhitelabelDomainsIdValidateParams) -> Result<crate::models::PostWhitelabelDomainsIdValidate200Response, Error<POstWhitelabelDomainsIdValidateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let on_behalf_of = params.on_behalf_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/whitelabel/domains/{id}/validate", local_var_configuration.base_path, id=id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = on_behalf_of {
        local_var_req_builder = local_var_req_builder.header("on-behalf-of", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<POstWhitelabelDomainsIdValidateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

