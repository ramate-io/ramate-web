/*
 * Email Activity (beta)
 *
 * The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data. The Beta endpoints for the new Email Activity APIs - functionality is subject to change without notice. You may not have access to this Beta endpoint.  Email Activity offers filtering and search by event type for two days worth of data. There is an optional add-on to store 60 days worth of data. This add-on also gives you access to the ability to download a CSV of the 60 days worth of email event data.
 *
 * The version of the OpenAPI document: 
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`p_ost_mail_send`]
#[derive(Clone, Debug, Default)]
pub struct POstMailSendParams {
    pub post_mail_send_request: Option<crate::models::PostMailSendRequest>
}


/// struct for typed errors of method [`p_ost_mail_send`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum POstMailSendError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status413(),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// The Mail Send endpoint allows you to send email over SendGrid’s v3 Web API, the most recent version of our API. If you are looking for documentation about the v2 Mail Send endpoint, see our [v2 API Reference](https://sendgrid.com/docs/API_Reference/Web_API/mail.html).  ## Helper Libraries  Twilio SendGrid provides libraries to help you quickly and easily integrate with the v3 Web API in 7 different languages:  * [C#](https://github.com/sendgrid/sendgrid-csharp)  * [Go](https://github.com/sendgrid/sendgrid-go) * [Java](https://github.com/sendgrid/sendgrid-java) * [Node JS](https://github.com/sendgrid/sendgrid-nodejs) * [PHP](https://github.com/sendgrid/sendgrid-php) * [Python](https://github.com/sendgrid/sendgrid-python) * [Ruby](https://github.com/sendgrid/sendgrid-ruby)  ## Dynamic Transactional Templates and Handlebars  In order to send a dynamic template, specify the template ID with the `template_id` parameter.   To specify handlebar substitutions, define your substitutions in the request JSON with this syntax:  ``` \"dynamic_template_data\": {       \"guest\": \"Jane Doe\",       \"partysize\": \"4\",       \"english\": true,       \"date\": \"April 1st, 2021\"     } ```  For more information about Dynamic Transactional Templates and Handlebars, see our documentation and reference pages.  * [How to send an email with Dynamic Transactional Templates ](https://sendgrid.com/docs/ui/sending-email/how-to-send-an-email-with-dynamic-transactional-templates/) * [Using Handlebars](https://sendgrid.com/docs/for-developers/sending-email/using-handlebars/)   ## Mail Body Compression  Mail body compression is available to some high volume accounts. Talk to your CSM if you are interested in this functionality. Mail body compression works by setting up a JSON payload as defined on this page, then compressing it with gzip (the gzip file can be no more than 30mb).  To use mail body compression:  1. Add a `Content-Encoding` header, with a value of `gzip`.      a. `Content-Encoding: gzip`  2. Send the gzip as a data-binary.      a. `--data-binary '@data.json.gz' `  ## Multiple Reply-To Emails  Using `reply_to_list` allows senders to include more than one recipient email address to receive reply and/or bounce messages from the recipient of the email.  ### Usage Considerations  * `reply_to` is mutually exclusive with `reply_to_list`. If both are used, then the API call will be rejected.  * The `reply_to_list` object, when used, must at least have an email parameter and may also contain a name parameter. * Each email address in the `reply_to_list` should be unique. * There is a limit of 1000 `reply_to_list` emails per mail/send request. * In SMTP calls, we will omit any invalid emails.  ### Possible 400 Error Messages  * `reply_to` is mutually exclusive with `reply_to_list`. * The `reply_to_list` object, when used, must at least have an email parameter and may also contain a name parameter. * Each email address in the `reply_to_list` should be unique. * There is a limit of X `reply_to` emails per mail/send request. * The `reply_to_list` email does not contain a valid address. * The `reply_to_list` email exceeds the maximum total length of X characters. * The `reply_to_list` email parameter is required.
pub async fn p_ost_mail_send(configuration: &configuration::Configuration, params: POstMailSendParams) -> Result<(), Error<POstMailSendError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let post_mail_send_request = params.post_mail_send_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/mail/send", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&post_mail_send_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<POstMailSendError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

